{"version":3,"sources":["localforage.js"],"names":["define","idbDriver","websqlDriver","localstorageDriver","serializer","Promise","executeCallback","executeTwoCallbacks","includes","isArray","DefinedDrivers","DriverSupport","DefaultDrivers","INDEXEDDB","WEBSQL","LOCALSTORAGE","DefaultDriverOrder","_driver","OptionalDriverMethods","LibraryMethods","concat","DefaultConfig","description","driver","slice","name","size","storeName","version","callWhenReady","localForageInstance","libraryMethod","_args","arguments","ready","then","apply","extend","i","length","arg","key","hasOwnProperty","LocalForage","[object Object]","options","driverTypeKey","driverName","this","defineDriver","_defaultConfig","_config","_driverSet","_initDriver","_ready","_dbInfo","_wrapLibraryMethodsWithReady","setDriver","catch","Error","replace","driverObject","callback","errorCallback","promise","resolve","reject","complianceError","driverMethods","len","driverMethodName","methodNotImplementedFactory","methodName","error","optionalDriverMethod","configureMissingMethods","setDriverSupport","support","console","info","_support","e","getDriverPromise","serializerPromise","self","drivers","supportedDrivers","_getSupportedDrivers","setDriverToConfig","extendSelfWithDriver","_extend","_initStorage","oldDriverSetDone","getDriver","currentDriverIndex","driverPromiseLoop","initDriver","libraryMethodsAndProperties","supports","push"],"mappings":"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","file":"../localforage.js","sourcesContent":["define([\n    './drivers/indexeddb',\n    './drivers/websql',\n    './drivers/localstorage',\n    './utils/serializer',\n    './utils/promise',\n    './utils/executeCallback',\n    './utils/executeTwoCallbacks',\n    './utils/includes',\n    './utils/isArray'\n], function (idbDriver, websqlDriver, localstorageDriver, serializer, Promise, executeCallback, executeTwoCallbacks, includes, isArray) {\n    'use strict';\n    // Drivers are stored here when `defineDriver()` is called.\n    // They are shared across all instances of localForage.\n    const DefinedDrivers = {};\n    const DriverSupport = {};\n    const DefaultDrivers = {\n        INDEXEDDB: idbDriver,\n        WEBSQL: websqlDriver,\n        LOCALSTORAGE: localstorageDriver\n    };\n    const DefaultDriverOrder = [\n        DefaultDrivers.INDEXEDDB._driver,\n        DefaultDrivers.WEBSQL._driver,\n        DefaultDrivers.LOCALSTORAGE._driver\n    ];\n    const OptionalDriverMethods = ['dropInstance'];\n    const LibraryMethods = [\n        'clear',\n        'getItem',\n        'iterate',\n        'key',\n        'keys',\n        'length',\n        'removeItem',\n        'setItem'\n    ].concat(OptionalDriverMethods);\n    const DefaultConfig = {\n        description: '',\n        driver: DefaultDriverOrder.slice(),\n        name: 'localforage',\n        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n        // we can use without a prompt.\n        size: 4980736,\n        storeName: 'keyvaluepairs',\n        version: 1\n    };\n    function callWhenReady(localForageInstance, libraryMethod) {\n        localForageInstance[libraryMethod] = function () {\n            const _args = arguments;\n            return localForageInstance.ready().then(function () {\n                return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n            });\n        };\n    }\n    function extend() {\n        for (let i = 1; i < arguments.length; i++) {\n            const arg = arguments[i];\n            if (arg) {\n                for (let key in arg) {\n                    if (arg.hasOwnProperty(key)) {\n                        if (isArray(arg[key])) {\n                            arguments[0][key] = arg[key].slice();\n                        } else {\n                            arguments[0][key] = arg[key];\n                        }\n                    }\n                }\n            }\n        }\n        return arguments[0];\n    }\n    class LocalForage {\n        constructor(options) {\n            for (let driverTypeKey in DefaultDrivers) {\n                if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                    const driver = DefaultDrivers[driverTypeKey];\n                    const driverName = driver._driver;\n                    this[driverTypeKey] = driverName;\n                    if (!DefinedDrivers[driverName]) {\n                        // we don't need to wait for the promise,\n                        // since the default drivers can be defined\n                        // in a blocking manner\n                        this.defineDriver(driver);\n                    }\n                }\n            }\n            this._defaultConfig = extend({}, DefaultConfig);\n            this._config = extend({}, this._defaultConfig, options);\n            this._driverSet = null;\n            this._initDriver = null;\n            this._ready = false;\n            this._dbInfo = null;\n            this._wrapLibraryMethodsWithReady();\n            this.setDriver(this._config.driver).catch(() => {\n            });\n        }    // Set any config values for localForage; can be called anytime before\n             // the first API call (e.g. `getItem`, `setItem`).\n             // We loop through options so we don't overwrite existing config\n             // values.\n\n        // Set any config values for localForage; can be called anytime before\n        // the first API call (e.g. `getItem`, `setItem`).\n        // We loop through options so we don't overwrite existing config\n        // values.\n        config(options) {\n            // If the options argument is an object, we use it to set values.\n            // Otherwise, we return either a specified config value or all\n            // config values.\n            if (typeof options === 'object') {\n                // If localforage is ready and fully initialized, we can't set\n                // any new configuration values. Instead, we return an error.\n                if (this._ready) {\n                    return new Error(\"Can't call config() after localforage \" + 'has been used.');\n                }\n                for (let i in options) {\n                    if (i === 'storeName') {\n                        options[i] = options[i].replace(/\\W/g, '_');\n                    }\n                    if (i === 'version' && typeof options[i] !== 'number') {\n                        return new Error('Database version must be a number.');\n                    }\n                    this._config[i] = options[i];\n                }    // after all config options are set and\n                     // the driver option is used, try setting it\n                // after all config options are set and\n                // the driver option is used, try setting it\n                if ('driver' in options && options.driver) {\n                    return this.setDriver(this._config.driver);\n                }\n                return true;\n            } else if (typeof options === 'string') {\n                return this._config[options];\n            } else {\n                return this._config;\n            }\n        }    // Used to define a custom driver, shared across all instances of\n             // localForage.\n\n        // Used to define a custom driver, shared across all instances of\n        // localForage.\n        defineDriver(driverObject, callback, errorCallback) {\n            const promise = new Promise(function (resolve, reject) {\n                try {\n                    const driverName = driverObject._driver;\n                    const complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');    // A driver name should be defined and not overlap with the\n                                                                                                                                                       // library-defined, default drivers.\n                    // A driver name should be defined and not overlap with the\n                    // library-defined, default drivers.\n                    if (!driverObject._driver) {\n                        reject(complianceError);\n                        return;\n                    }\n                    const driverMethods = LibraryMethods.concat('_initStorage');\n                    for (let i = 0, len = driverMethods.length; i < len; i++) {\n                        const driverMethodName = driverMethods[i];    // when the property is there,\n                                                                      // it should be a method even when optional\n                        // when the property is there,\n                        // it should be a method even when optional\n                        const isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                        if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                            reject(complianceError);\n                            return;\n                        }\n                    }\n                    const configureMissingMethods = function () {\n                        const methodNotImplementedFactory = function (methodName) {\n                            return function () {\n                                const error = new Error(`Method ${ methodName } is not implemented by the current driver`);\n                                const promise = Promise.reject(error);\n                                executeCallback(promise, arguments[arguments.length - 1]);\n                                return promise;\n                            };\n                        };\n                        for (let i = 0, len = OptionalDriverMethods.length; i < len; i++) {\n                            const optionalDriverMethod = OptionalDriverMethods[i];\n                            if (!driverObject[optionalDriverMethod]) {\n                                driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                            }\n                        }\n                    };\n                    configureMissingMethods();\n                    const setDriverSupport = function (support) {\n                        if (DefinedDrivers[driverName]) {\n                            console.info(`Redefining LocalForage driver: ${ driverName }`);\n                        }\n                        DefinedDrivers[driverName] = driverObject;\n                        DriverSupport[driverName] = support;    // don't use a then, so that we can define\n                                                                // drivers that have simple _support methods\n                                                                // in a blocking manner\n                        // don't use a then, so that we can define\n                        // drivers that have simple _support methods\n                        // in a blocking manner\n                        resolve();\n                    };\n                    if ('_support' in driverObject) {\n                        if (driverObject._support && typeof driverObject._support === 'function') {\n                            driverObject._support().then(setDriverSupport, reject);\n                        } else {\n                            setDriverSupport(!!driverObject._support);\n                        }\n                    } else {\n                        setDriverSupport(true);\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            });\n            executeTwoCallbacks(promise, callback, errorCallback);\n            return promise;\n        }\n        driver() {\n            return this._driver || null;\n        }\n        getDriver(driverName, callback, errorCallback) {\n            const getDriverPromise = DefinedDrivers[driverName] ? Promise.resolve(DefinedDrivers[driverName]) : Promise.reject(new Error('Driver not found.'));\n            executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n            return getDriverPromise;\n        }\n        getSerializer(callback) {\n            const serializerPromise = Promise.resolve(serializer);\n            executeTwoCallbacks(serializerPromise, callback);\n            return serializerPromise;\n        }\n        ready(callback) {\n            const self = this;\n            const promise = self._driverSet.then(() => {\n                if (self._ready === null) {\n                    self._ready = self._initDriver();\n                }\n                return self._ready;\n            });\n            executeTwoCallbacks(promise, callback, callback);\n            return promise;\n        }\n        setDriver(drivers, callback, errorCallback) {\n            const self = this;\n            if (!isArray(drivers)) {\n                drivers = [drivers];\n            }\n            const supportedDrivers = this._getSupportedDrivers(drivers);\n            function setDriverToConfig() {\n                self._config.driver = self.driver();\n            }\n            function extendSelfWithDriver(driver) {\n                self._extend(driver);\n                setDriverToConfig();\n                self._ready = self._initStorage(self._config);\n                return self._ready;\n            }\n            function initDriver(supportedDrivers) {\n                return function () {\n                    let currentDriverIndex = 0;\n                    function driverPromiseLoop() {\n                        while (currentDriverIndex < supportedDrivers.length) {\n                            let driverName = supportedDrivers[currentDriverIndex];\n                            currentDriverIndex++;\n                            self._dbInfo = null;\n                            self._ready = null;\n                            return self.getDriver(driverName).then(extendSelfWithDriver).catch(driverPromiseLoop);\n                        }\n                        setDriverToConfig();\n                        const error = new Error('No available storage method found.');\n                        self._driverSet = Promise.reject(error);\n                        return self._driverSet;\n                    }\n                    return driverPromiseLoop();\n                };\n            }    // There might be a driver initialization in progress\n                 // so wait for it to finish in order to avoid a possible\n                 // race condition to set _dbInfo\n            // There might be a driver initialization in progress\n            // so wait for it to finish in order to avoid a possible\n            // race condition to set _dbInfo\n            const oldDriverSetDone = this._driverSet !== null ? this._driverSet.catch(() => Promise.resolve()) : Promise.resolve();\n            this._driverSet = oldDriverSetDone.then(() => {\n                const driverName = supportedDrivers[0];\n                self._dbInfo = null;\n                self._ready = null;\n                return self.getDriver(driverName).then(driver => {\n                    self._driver = driver._driver;\n                    setDriverToConfig();\n                    self._wrapLibraryMethodsWithReady();\n                    self._initDriver = initDriver(supportedDrivers);\n                });\n            }).catch(() => {\n                setDriverToConfig();\n                const error = new Error('No available storage method found.');\n                self._driverSet = Promise.reject(error);\n                return self._driverSet;\n            });\n            executeTwoCallbacks(this._driverSet, callback, errorCallback);\n            return this._driverSet;\n        }\n        supports(driverName) {\n            return !!DriverSupport[driverName];\n        }\n        _extend(libraryMethodsAndProperties) {\n            extend(this, libraryMethodsAndProperties);\n        }\n        _getSupportedDrivers(drivers) {\n            const supportedDrivers = [];\n            for (let i = 0, len = drivers.length; i < len; i++) {\n                const driverName = drivers[i];\n                if (this.supports(driverName)) {\n                    supportedDrivers.push(driverName);\n                }\n            }\n            return supportedDrivers;\n        }\n        _wrapLibraryMethodsWithReady() {\n            // Add a stub for each driver API method that delays the call to the\n            // corresponding driver method until localForage is ready. These stubs\n            // will be replaced by the driver methods as soon as the driver is\n            // loaded, so there is no performance impact.\n            for (let i = 0, len = LibraryMethods.length; i < len; i++) {\n                callWhenReady(this, LibraryMethods[i]);\n            }\n        }\n        createInstance(options) {\n            return new LocalForage(options);\n        }\n    }    // The actual localForage object that we expose as a module or via a\n         // global. It's extended by pulling in one of our other libraries.\n    // The actual localForage object that we expose as a module or via a\n    // global. It's extended by pulling in one of our other libraries.\n    return new LocalForage();\n});"]}