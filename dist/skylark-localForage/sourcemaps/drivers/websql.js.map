{"version":3,"sources":["drivers/websql.js"],"names":["define","isWebSQLValid","serializer","Promise","executeCallback","normalizeKey","getCallback","createDbTable","t","dbInfo","callback","errorCallback","executeSql","storeName","tryExecuteSql","sqlStatement","args","error","code","SYNTAX_ERR","results","rows","length","_driver","_initStorage","options","self","this","db","i","toString","dbInfoPromise","resolve","reject","openDatabase","name","String","version","description","size","e","transaction","_dbInfo","_support","iterate","iterator","promise","ready","then","item","result","value","deserialize","key","catch","getItem","setItem","_setItem","retriesLeft","undefined","originalValue","serialize","sqlError","QUOTA_ERR","apply","removeItem","clear","c","n","keys","push","dropInstance","arguments","currentConfig","config","storeNames","getAllStoreNames","operationInfo","dropTable","operations","len","all"],"mappings":"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","file":"../../drivers/websql.js","sourcesContent":["define([\n    '../utils/isWebSQLValid',\n    '../utils/serializer',\n    '../utils/promise',\n    '../utils/executeCallback',\n    '../utils/normalizeKey',\n    '../utils/getCallback'\n], function (isWebSQLValid, serializer, Promise, executeCallback, normalizeKey, getCallback) {\n    'use strict';\n    /*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n    function createDbTable(t, dbInfo, callback, errorCallback) {\n        t.executeSql(`CREATE TABLE IF NOT EXISTS ${ dbInfo.storeName } ` + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n    }    // Open the WebSQL database (automatically creates one if one didn't\n         // previously exist), using any options set in the config.\n    // Open the WebSQL database (automatically creates one if one didn't\n    // previously exist), using any options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = { db: null };\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n            }\n        }\n        var dbInfoPromise = new Promise(function (resolve, reject) {\n            // Open the database; the openDatabase API will automatically\n            // create it for us if it doesn't exist.\n            try {\n                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n            } catch (e) {\n                return reject(e);\n            }    // Create our key/value table if it doesn't exist.\n            // Create our key/value table if it doesn't exist.\n            dbInfo.db.transaction(function (t) {\n                createDbTable(t, dbInfo, function () {\n                    self._dbInfo = dbInfo;\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            }, reject);\n        });\n        dbInfo.serializer = serializer;\n        return dbInfoPromise;\n    }\n    function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n        t.executeSql(sqlStatement, args, callback, function (t, error) {\n            if (error.code === error.SYNTAX_ERR) {\n                t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                    if (!results.rows.length) {\n                        // if the table is missing (was deleted)\n                        // re-create it table and retry\n                        createDbTable(t, dbInfo, function () {\n                            t.executeSql(sqlStatement, args, callback, errorCallback);\n                        }, errorCallback);\n                    } else {\n                        errorCallback(t, error);\n                    }\n                }, errorCallback);\n            } else {\n                errorCallback(t, error);\n            }\n        }, errorCallback);\n    }\n    function getItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `SELECT * FROM ${ dbInfo.storeName } WHERE key = ? LIMIT 1`, [key], function (t, results) {\n                        var result = results.rows.length ? results.rows.item(0).value : null;    // Check to see if this is serialized content we need to\n                                                                                                 // unpack.\n                        // Check to see if this is serialized content we need to\n                        // unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n                        resolve(result);\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function iterate(iterator, callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `SELECT * FROM ${ dbInfo.storeName }`, [], function (t, results) {\n                        var rows = results.rows;\n                        var length = rows.length;\n                        for (var i = 0; i < length; i++) {\n                            var item = rows.item(i);\n                            var result = item.value;    // Check to see if this is serialized content\n                                                        // we need to unpack.\n                            // Check to see if this is serialized content\n                            // we need to unpack.\n                            if (result) {\n                                result = dbInfo.serializer.deserialize(result);\n                            }\n                            result = iterator(result, item.key, i + 1);    // void(0) prevents problems with redefinition\n                                                                           // of `undefined`.\n                            // void(0) prevents problems with redefinition\n                            // of `undefined`.\n                            if (result !== void 0) {\n                                resolve(result);\n                                return;\n                            }\n                        }\n                        resolve();\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function _setItem(key, value, callback, retriesLeft) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                // The localStorage API doesn't return undefined values in an\n                // \"expected\" way, so undefined is always cast to null in all\n                // drivers. See: https://github.com/mozilla/localForage/pull/42\n                if (value === undefined) {\n                    value = null;\n                }    // Save the original value to pass to the callback.\n                // Save the original value to pass to the callback.\n                var originalValue = value;\n                var dbInfo = self._dbInfo;\n                dbInfo.serializer.serialize(value, function (value, error) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        dbInfo.db.transaction(function (t) {\n                            tryExecuteSql(t, dbInfo, `INSERT OR REPLACE INTO ${ dbInfo.storeName } ` + '(key, value) VALUES (?, ?)', [\n                                key,\n                                value\n                            ], function () {\n                                resolve(originalValue);\n                            }, function (t, error) {\n                                reject(error);\n                            });\n                        }, function (sqlError) {\n                            // The transaction failed; check\n                            // to see if it's a quota error.\n                            if (sqlError.code === sqlError.QUOTA_ERR) {\n                                // We reject the callback outright for now, but\n                                // it's worth trying to re-run the transaction.\n                                // Even if the user accepts the prompt to use\n                                // more storage on Safari, this error will\n                                // be called.\n                                //\n                                // Try to re-run the transaction.\n                                if (retriesLeft > 0) {\n                                    resolve(_setItem.apply(self, [\n                                        key,\n                                        originalValue,\n                                        callback,\n                                        retriesLeft - 1\n                                    ]));\n                                    return;\n                                }\n                                reject(sqlError);\n                            }\n                        });\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function setItem(key, value, callback) {\n        return _setItem.apply(this, [\n            key,\n            value,\n            callback,\n            1\n        ]);\n    }\n    function removeItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `DELETE FROM ${ dbInfo.storeName } WHERE key = ?`, [key], function () {\n                        resolve();\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Deletes every item in the table.\n         // TODO: Find out if this resets the AUTO_INCREMENT number.\n    // Deletes every item in the table.\n    // TODO: Find out if this resets the AUTO_INCREMENT number.\n    function clear(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `DELETE FROM ${ dbInfo.storeName }`, [], function () {\n                        resolve();\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Does a simple `COUNT(key)` to get the number of items stored in\n         // localForage.\n    // Does a simple `COUNT(key)` to get the number of items stored in\n    // localForage.\n    function length(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    // Ahhh, SQL makes this one soooooo easy.\n                    tryExecuteSql(t, dbInfo, `SELECT COUNT(key) as c FROM ${ dbInfo.storeName }`, [], function (t, results) {\n                        var result = results.rows.item(0).c;\n                        resolve(result);\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Return the key located at key index X; essentially gets the key from a\n         // `WHERE id = ?`. This is the most efficient way I can think to implement\n         // this rarely-used (in my experience) part of the API, but it can seem\n         // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n         // the ID of each key will change every time it's updated. Perhaps a stored\n         // procedure for the `setItem()` SQL would solve this problem?\n         // TODO: Don't change ID on `setItem()`.\n    // Return the key located at key index X; essentially gets the key from a\n    // `WHERE id = ?`. This is the most efficient way I can think to implement\n    // this rarely-used (in my experience) part of the API, but it can seem\n    // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n    // the ID of each key will change every time it's updated. Perhaps a stored\n    // procedure for the `setItem()` SQL would solve this problem?\n    // TODO: Don't change ID on `setItem()`.\n    function key(n, callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `SELECT key FROM ${ dbInfo.storeName } WHERE id = ? LIMIT 1`, [n + 1], function (t, results) {\n                        var result = results.rows.length ? results.rows.item(0).key : null;\n                        resolve(result);\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function keys(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `SELECT key FROM ${ dbInfo.storeName }`, [], function (t, results) {\n                        var keys = [];\n                        for (var i = 0; i < results.rows.length; i++) {\n                            keys.push(results.rows.item(i).key);\n                        }\n                        resolve(keys);\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // https://www.w3.org/TR/webdatabase/#databases\n         // > There is no way to enumerate or delete the databases available for an origin from this API.\n    // https://www.w3.org/TR/webdatabase/#databases\n    // > There is no way to enumerate or delete the databases available for an origin from this API.\n    function getAllStoreNames(db) {\n        return new Promise(function (resolve, reject) {\n            db.transaction(function (t) {\n                t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                    var storeNames = [];\n                    for (var i = 0; i < results.rows.length; i++) {\n                        storeNames.push(results.rows.item(i).name);\n                    }\n                    resolve({\n                        db,\n                        storeNames\n                    });\n                }, function (t, error) {\n                    reject(error);\n                });\n            }, function (sqlError) {\n                reject(sqlError);\n            });\n        });\n    }\n    function dropInstance(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        var currentConfig = this.config();\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n            promise = Promise.reject('Invalid arguments');\n        } else {\n            promise = new Promise(function (resolve) {\n                var db;\n                if (options.name === currentConfig.name) {\n                    // use the db reference of the current instance\n                    db = self._dbInfo.db;\n                } else {\n                    db = openDatabase(options.name, '', '', 0);\n                }\n                if (!options.storeName) {\n                    // drop all database tables\n                    resolve(getAllStoreNames(db));\n                } else {\n                    resolve({\n                        db,\n                        storeNames: [options.storeName]\n                    });\n                }\n            }).then(function (operationInfo) {\n                return new Promise(function (resolve, reject) {\n                    operationInfo.db.transaction(function (t) {\n                        function dropTable(storeName) {\n                            return new Promise(function (resolve, reject) {\n                                t.executeSql(`DROP TABLE IF EXISTS ${ storeName }`, [], function () {\n                                    resolve();\n                                }, function (t, error) {\n                                    reject(error);\n                                });\n                            });\n                        }\n                        var operations = [];\n                        for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                            operations.push(dropTable(operationInfo.storeNames[i]));\n                        }\n                        Promise.all(operations).then(function () {\n                            resolve();\n                        }).catch(function (e) {\n                            reject(e);\n                        });\n                    }, function (sqlError) {\n                        reject(sqlError);\n                    });\n                });\n            });\n        }\n        executeCallback(promise, callback);\n        return promise;\n    }\n    var webSQLStorage = {\n        _driver: 'webSQLStorage',\n        _initStorage: _initStorage,\n        _support: isWebSQLValid(),\n        iterate: iterate,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys,\n        dropInstance: dropInstance\n    };\n    return webSQLStorage;\n});"]}