{"version":3,"sources":["drivers/indexeddb.js"],"names":["define","isIndexedDBValid","createBlob","idb","Promise","executeCallback","executeTwoCallbacks","normalizeKey","getCallback","DETECT_BLOB_SUPPORT_STORE","supportsBlobs","dbContexts","toString","Object","prototype","READ_ONLY","READ_WRITE","_checkBlobSupport","resolve","txn","transaction","blob","objectStore","put","onabort","e","preventDefault","stopPropagation","oncomplete","matchedChrome","navigator","userAgent","match","matchedEdge","parseInt","catch","_checkBlobSupportWithoutCaching","then","value","_deferReadiness","dbInfo","dbContext","name","deferredOperation","promise","reject","deferredOperations","push","dbReady","_advanceReadiness","pop","_rejectReadiness","err","_getConnection","upgradeNeeded","forages","db","close","dbArgs","version","openreq","open","apply","onupgradeneeded","result","createObjectStore","storeName","oldVersion","ex","console","warn","newVersion","onerror","error","onsuccess","onversionchange","target","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_decodeBlob","encodedBlob","arrayBuff","bin","length","buf","ArrayBuffer","arr","Uint8Array","i","charCodeAt","_binStringToArrayBuffer","atob","data","type","_isEncodedBlob","__local_forage_encoded_blob","_fullyReady","callback","self","this","_initReady","_dbInfo","createTransaction","mode","retries","undefined","tx","forage","_tryReconnect","_driver","_initStorage","options","ready","initPromises","ignoreErrors","j","slice","all","_defaultConfig","k","_support","iterate","iterator","req","openCursor","iterationNumber","cursor","key","continue","getItem","get","setItem","call","blobSupport","reader","FileReader","onloadend","base64","btoa","readAsBinaryString","store","removeItem","delete","clear","count","n","advanced","openKeyCursor","advance","keys","dropInstance","arguments","currentConfig","config","dbPromise","deleteObjectStore","deleteDatabase","onblocked"],"mappings":"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","file":"../../drivers/indexeddb.js","sourcesContent":["define([\n    '../utils/isIndexedDBValid',\n    '../utils/createBlob',\n    '../utils/idb',\n    '../utils/promise',\n    '../utils/executeCallback',\n    '../utils/executeTwoCallbacks',\n    '../utils/normalizeKey',\n    '../utils/getCallback'\n], function (isIndexedDBValid, createBlob, idb, Promise, executeCallback, executeTwoCallbacks, normalizeKey, getCallback) {\n    'use strict';\n    // Some code originally from async_storage.js in\n    // [Gaia](https://github.com/mozilla-b2g/gaia).\n    const DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\n    let supportsBlobs;\n    const dbContexts = {};\n    const toString = Object.prototype.toString;    // Transaction Modes\n    // Transaction Modes\n    const READ_ONLY = 'readonly';\n    const READ_WRITE = 'readwrite';    // Transform a binary string to an array buffer, because otherwise\n                                       // weird stuff happens when you try to work with the binary string directly.\n                                       // It is known.\n                                       // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n                                       // encode-decode-image-with-base64-breaks-image (2013-04-21)\n    // Transform a binary string to an array buffer, because otherwise\n    // weird stuff happens when you try to work with the binary string directly.\n    // It is known.\n    // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n    // encode-decode-image-with-base64-breaks-image (2013-04-21)\n    function _binStringToArrayBuffer(bin) {\n        var length = bin.length;\n        var buf = new ArrayBuffer(length);\n        var arr = new Uint8Array(buf);\n        for (var i = 0; i < length; i++) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return buf;\n    }    //\n         // Blobs are not supported in all versions of IndexedDB, notably\n         // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n         //\n         // Various other blob bugs exist in Chrome v37-42 (inclusive).\n         // Detecting them is expensive and confusing to users, and Chrome 37-42\n         // is at very low usage worldwide, so we do a hacky userAgent check instead.\n         //\n         // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n         // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n         // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n         //\n         // Code borrowed from PouchDB. See:\n         // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n         //\n    //\n    // Blobs are not supported in all versions of IndexedDB, notably\n    // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n    //\n    // Various other blob bugs exist in Chrome v37-42 (inclusive).\n    // Detecting them is expensive and confusing to users, and Chrome 37-42\n    // is at very low usage worldwide, so we do a hacky userAgent check instead.\n    //\n    // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n    // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n    // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n    //\n    // Code borrowed from PouchDB. See:\n    // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n    //\n    function _checkBlobSupportWithoutCaching(idb) {\n        return new Promise(function (resolve) {\n            var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n            var blob = createBlob(['']);\n            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n            txn.onabort = function (e) {\n                // If the transaction aborts now its due to not being able to\n                // write to the database, likely due to the disk being full\n                e.preventDefault();\n                e.stopPropagation();\n                resolve(false);\n            };\n            txn.oncomplete = function () {\n                var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n                var matchedEdge = navigator.userAgent.match(/Edge\\//);    // MS Edge pretends to be Chrome 42:\n                                                                          // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n                // MS Edge pretends to be Chrome 42:\n                // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n                resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n            };\n        }).catch(function () {\n            return false;    // error, so assume unsupported\n        });\n    }\n    // error, so assume unsupported\n    function _checkBlobSupport(idb) {\n        if (typeof supportsBlobs === 'boolean') {\n            return Promise.resolve(supportsBlobs);\n        }\n        return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n            supportsBlobs = value;\n            return supportsBlobs;\n        });\n    }\n    function _deferReadiness(dbInfo) {\n        var dbContext = dbContexts[dbInfo.name];    // Create a deferred object representing the current database operation.\n        // Create a deferred object representing the current database operation.\n        var deferredOperation = {};\n        deferredOperation.promise = new Promise(function (resolve, reject) {\n            deferredOperation.resolve = resolve;\n            deferredOperation.reject = reject;\n        });    // Enqueue the deferred operation.\n        // Enqueue the deferred operation.\n        dbContext.deferredOperations.push(deferredOperation);    // Chain its promise to the database readiness.\n        // Chain its promise to the database readiness.\n        if (!dbContext.dbReady) {\n            dbContext.dbReady = deferredOperation.promise;\n        } else {\n            dbContext.dbReady = dbContext.dbReady.then(function () {\n                return deferredOperation.promise;\n            });\n        }\n    }\n    function _advanceReadiness(dbInfo) {\n        var dbContext = dbContexts[dbInfo.name];    // Dequeue a deferred operation.\n        // Dequeue a deferred operation.\n        var deferredOperation = dbContext.deferredOperations.pop();    // Resolve its promise (which is part of the database readiness\n                                                                       // chain of promises).\n        // Resolve its promise (which is part of the database readiness\n        // chain of promises).\n        if (deferredOperation) {\n            deferredOperation.resolve();\n            return deferredOperation.promise;\n        }\n    }\n    function _rejectReadiness(dbInfo, err) {\n        var dbContext = dbContexts[dbInfo.name];    // Dequeue a deferred operation.\n        // Dequeue a deferred operation.\n        var deferredOperation = dbContext.deferredOperations.pop();    // Reject its promise (which is part of the database readiness\n                                                                       // chain of promises).\n        // Reject its promise (which is part of the database readiness\n        // chain of promises).\n        if (deferredOperation) {\n            deferredOperation.reject(err);\n            return deferredOperation.promise;\n        }\n    }\n    function _getConnection(dbInfo, upgradeNeeded) {\n        return new Promise(function (resolve, reject) {\n            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n            if (dbInfo.db) {\n                if (upgradeNeeded) {\n                    _deferReadiness(dbInfo);\n                    dbInfo.db.close();\n                } else {\n                    return resolve(dbInfo.db);\n                }\n            }\n            var dbArgs = [dbInfo.name];\n            if (upgradeNeeded) {\n                dbArgs.push(dbInfo.version);\n            }\n            var openreq = idb.open.apply(idb, dbArgs);\n            if (upgradeNeeded) {\n                openreq.onupgradeneeded = function (e) {\n                    var db = openreq.result;\n                    try {\n                        db.createObjectStore(dbInfo.storeName);\n                        if (e.oldVersion <= 1) {\n                            // Added when support for blob shims was added\n                            db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                        }\n                    } catch (ex) {\n                        if (ex.name === 'ConstraintError') {\n                            console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                        } else {\n                            throw ex;\n                        }\n                    }\n                };\n            }\n            openreq.onerror = function (e) {\n                e.preventDefault();\n                reject(openreq.error);\n            };\n            openreq.onsuccess = function () {\n                var db = openreq.result;\n                db.onversionchange = function (e) {\n                    // Triggered when the database is modified (e.g. adding an objectStore) or\n                    // deleted (even when initiated by other sessions in different tabs).\n                    // Closing the connection here prevents those operations from being blocked.\n                    // If the database is accessed again later by this instance, the connection\n                    // will be reopened or the database recreated as needed.\n                    e.target.close();\n                };\n                resolve(db);\n                _advanceReadiness(dbInfo);\n            };\n        });\n    }\n    function _getOriginalConnection(dbInfo) {\n        return _getConnection(dbInfo, false);\n    }\n    function _getUpgradedConnection(dbInfo) {\n        return _getConnection(dbInfo, true);\n    }\n    function _isUpgradeNeeded(dbInfo, defaultVersion) {\n        if (!dbInfo.db) {\n            return true;\n        }\n        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n        var isDowngrade = dbInfo.version < dbInfo.db.version;\n        var isUpgrade = dbInfo.version > dbInfo.db.version;\n        if (isDowngrade) {\n            // If the version is not the default one\n            // then warn for impossible downgrade.\n            if (dbInfo.version !== defaultVersion) {\n                console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n            }    // Align the versions to prevent errors.\n            // Align the versions to prevent errors.\n            dbInfo.version = dbInfo.db.version;\n        }\n        if (isUpgrade || isNewStore) {\n            // If the store is new then increment the version (if needed).\n            // This will trigger an \"upgradeneeded\" event which is required\n            // for creating a store.\n            if (isNewStore) {\n                var incVersion = dbInfo.db.version + 1;\n                if (incVersion > dbInfo.version) {\n                    dbInfo.version = incVersion;\n                }\n            }\n            return true;\n        }\n        return false;\n    }    // encode a blob for indexeddb engines that don't support blobs\n    // encode a blob for indexeddb engines that don't support blobs\n    function _encodeBlob(blob) {\n        return new Promise(function (resolve, reject) {\n            var reader = new FileReader();\n            reader.onerror = reject;\n            reader.onloadend = function (e) {\n                var base64 = btoa(e.target.result || '');\n                resolve({\n                    __local_forage_encoded_blob: true,\n                    data: base64,\n                    type: blob.type\n                });\n            };\n            reader.readAsBinaryString(blob);\n        });\n    }    // decode an encoded blob\n    // decode an encoded blob\n    function _decodeBlob(encodedBlob) {\n        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n        return createBlob([arrayBuff], { type: encodedBlob.type });\n    }    // is this one of our fancy encoded blobs?\n    // is this one of our fancy encoded blobs?\n    function _isEncodedBlob(value) {\n        return value && value.__local_forage_encoded_blob;\n    }    // Specialize the default `ready()` function by making it dependent\n         // on the current database operations. Thus, the driver will be actually\n         // ready when it's been initialized (default) *and* there are no pending\n         // operations on the database (initiated by some other instances).\n    // Specialize the default `ready()` function by making it dependent\n    // on the current database operations. Thus, the driver will be actually\n    // ready when it's been initialized (default) *and* there are no pending\n    // operations on the database (initiated by some other instances).\n    function _fullyReady(callback) {\n        var self = this;\n        var promise = self._initReady().then(function () {\n            var dbContext = dbContexts[self._dbInfo.name];\n            if (dbContext && dbContext.dbReady) {\n                return dbContext.dbReady;\n            }\n        });\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    }    // Try to establish a new db connection to replace the\n         // current one which is broken (i.e. experiencing\n         // InvalidStateError while creating a transaction).\n    // Try to establish a new db connection to replace the\n    // current one which is broken (i.e. experiencing\n    // InvalidStateError while creating a transaction).\n    function _tryReconnect(dbInfo) {\n        _deferReadiness(dbInfo);\n        var dbContext = dbContexts[dbInfo.name];\n        var forages = dbContext.forages;\n        for (var i = 0; i < forages.length; i++) {\n            const forage = forages[i];\n            if (forage._dbInfo.db) {\n                forage._dbInfo.db.close();\n                forage._dbInfo.db = null;\n            }\n        }\n        dbInfo.db = null;\n        return _getOriginalConnection(dbInfo).then(db => {\n            dbInfo.db = db;\n            if (_isUpgradeNeeded(dbInfo)) {\n                // Reopen the database for upgrading.\n                return _getUpgradedConnection(dbInfo);\n            }\n            return db;\n        }).then(db => {\n            // store the latest db reference\n            // in case the db was upgraded\n            dbInfo.db = dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n        }).catch(err => {\n            _rejectReadiness(dbInfo, err);\n            throw err;\n        });\n    }    // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n         // so we have to do it with callbacks\n    // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n    // so we have to do it with callbacks\n    function createTransaction(dbInfo, mode, callback, retries) {\n        if (retries === undefined) {\n            retries = 1;\n        }\n        try {\n            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n            callback(null, tx);\n        } catch (err) {\n            if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n                return Promise.resolve().then(() => {\n                    if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                        // increase the db version, to create the new ObjectStore\n                        if (dbInfo.db) {\n                            dbInfo.version = dbInfo.db.version + 1;\n                        }    // Reopen the database for upgrading.\n                        // Reopen the database for upgrading.\n                        return _getUpgradedConnection(dbInfo);\n                    }\n                }).then(() => {\n                    return _tryReconnect(dbInfo).then(function () {\n                        createTransaction(dbInfo, mode, callback, retries - 1);\n                    });\n                }).catch(callback);\n            }\n            callback(err);\n        }\n    }\n    function createDbContext() {\n        return {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n    }    // Open the IndexedDB database (automatically creates one if one didn't\n         // previously exist), using any options set in the config.\n    // Open the IndexedDB database (automatically creates one if one didn't\n    // previously exist), using any options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = { db: null };\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = options[i];\n            }\n        }    // Get the current context of the database;\n        // Get the current context of the database;\n        var dbContext = dbContexts[dbInfo.name];    // ...or create a new context.\n        // ...or create a new context.\n        if (!dbContext) {\n            dbContext = createDbContext();    // Register the new context in the global container.\n            // Register the new context in the global container.\n            dbContexts[dbInfo.name] = dbContext;\n        }    // Register itself as a running localForage in the current context.\n        // Register itself as a running localForage in the current context.\n        dbContext.forages.push(self);    // Replace the default `ready()` function with the specialized one.\n        // Replace the default `ready()` function with the specialized one.\n        if (!self._initReady) {\n            self._initReady = self.ready;\n            self.ready = _fullyReady;\n        }    // Create an array of initialization states of the related localForages.\n        // Create an array of initialization states of the related localForages.\n        var initPromises = [];\n        function ignoreErrors() {\n            // Don't handle errors here,\n            // just makes sure related localForages aren't pending.\n            return Promise.resolve();\n        }\n        for (var j = 0; j < dbContext.forages.length; j++) {\n            var forage = dbContext.forages[j];\n            if (forage !== self) {\n                // Don't wait for itself...\n                initPromises.push(forage._initReady().catch(ignoreErrors));\n            }\n        }    // Take a snapshot of the related localForages.\n        // Take a snapshot of the related localForages.\n        var forages = dbContext.forages.slice(0);    // Initialize the connection process only when\n                                                     // all the related localForages aren't pending.\n        // Initialize the connection process only when\n        // all the related localForages aren't pending.\n        return Promise.all(initPromises).then(function () {\n            dbInfo.db = dbContext.db;    // Get the connection or open a new one without upgrade.\n            // Get the connection or open a new one without upgrade.\n            return _getOriginalConnection(dbInfo);\n        }).then(function (db) {\n            dbInfo.db = db;\n            if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n                // Reopen the database for upgrading.\n                return _getUpgradedConnection(dbInfo);\n            }\n            return db;\n        }).then(function (db) {\n            dbInfo.db = dbContext.db = db;\n            self._dbInfo = dbInfo;    // Share the final connection amongst related localForages.\n            // Share the final connection amongst related localForages.\n            for (var k = 0; k < forages.length; k++) {\n                var forage = forages[k];\n                if (forage !== self) {\n                    // Self is already up-to-date.\n                    forage._dbInfo.db = dbInfo.db;\n                    forage._dbInfo.version = dbInfo.version;\n                }\n            }\n        });\n    }\n    function getItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.get(key);\n                        req.onsuccess = function () {\n                            var value = req.result;\n                            if (value === undefined) {\n                                value = null;\n                            }\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            resolve(value);\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Iterate over all items stored in database.\n    // Iterate over all items stored in database.\n    function iterate(iterator, callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.openCursor();\n                        var iterationNumber = 1;\n                        req.onsuccess = function () {\n                            var cursor = req.result;\n                            if (cursor) {\n                                var value = cursor.value;\n                                if (_isEncodedBlob(value)) {\n                                    value = _decodeBlob(value);\n                                }\n                                var result = iterator(value, cursor.key, iterationNumber++);    // when the iterator callback returns any\n                                                                                                // (non-`undefined`) value, then we stop\n                                                                                                // the iteration immediately\n                                // when the iterator callback returns any\n                                // (non-`undefined`) value, then we stop\n                                // the iteration immediately\n                                if (result !== void 0) {\n                                    resolve(result);\n                                } else {\n                                    cursor.continue();\n                                }\n                            } else {\n                                resolve();\n                            }\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function setItem(key, value, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            var dbInfo;\n            self.ready().then(function () {\n                dbInfo = self._dbInfo;\n                if (toString.call(value) === '[object Blob]') {\n                    return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                        if (blobSupport) {\n                            return value;\n                        }\n                        return _encodeBlob(value);\n                    });\n                }\n                return value;\n            }).then(function (value) {\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);    // The reason we don't _save_ null is because IE 10 does\n                                                                                        // not support saving the `null` type in IndexedDB. How\n                                                                                        // ironic, given the bug below!\n                                                                                        // See: https://github.com/mozilla/localForage/issues/161\n                        // The reason we don't _save_ null is because IE 10 does\n                        // not support saving the `null` type in IndexedDB. How\n                        // ironic, given the bug below!\n                        // See: https://github.com/mozilla/localForage/issues/161\n                        if (value === null) {\n                            value = undefined;\n                        }\n                        var req = store.put(value, key);\n                        transaction.oncomplete = function () {\n                            // Cast to undefined so the value passed to\n                            // callback/promise is the same as what one would get out\n                            // of `getItem()` later. This leads to some weirdness\n                            // (setItem('foo', undefined) will return `null`), but\n                            // it's not my fault localStorage is our baseline and that\n                            // it's weird.\n                            if (value === undefined) {\n                                value = null;\n                            }\n                            resolve(value);\n                        };\n                        transaction.onabort = transaction.onerror = function () {\n                            var err = req.error ? req.error : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function removeItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);    // We use a Grunt task to make this safe for IE and some\n                                                                                        // versions of Android (including those used by Cordova).\n                                                                                        // Normally IE won't like `.delete()` and will insist on\n                                                                                        // using `['delete']()`, but we have a build step that\n                                                                                        // fixes this for us now.\n                        // We use a Grunt task to make this safe for IE and some\n                        // versions of Android (including those used by Cordova).\n                        // Normally IE won't like `.delete()` and will insist on\n                        // using `['delete']()`, but we have a build step that\n                        // fixes this for us now.\n                        var req = store.delete(key);\n                        transaction.oncomplete = function () {\n                            resolve();\n                        };\n                        transaction.onerror = function () {\n                            reject(req.error);\n                        };    // The request will be also be aborted if we've exceeded our storage\n                              // space.\n                        // The request will be also be aborted if we've exceeded our storage\n                        // space.\n                        transaction.onabort = function () {\n                            var err = req.error ? req.error : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function clear(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.clear();\n                        transaction.oncomplete = function () {\n                            resolve();\n                        };\n                        transaction.onabort = transaction.onerror = function () {\n                            var err = req.error ? req.error : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function length(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.count();\n                        req.onsuccess = function () {\n                            resolve(req.result);\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function key(n, callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (n < 0) {\n                resolve(null);\n                return;\n            }\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var advanced = false;\n                        var req = store.openKeyCursor();\n                        req.onsuccess = function () {\n                            var cursor = req.result;\n                            if (!cursor) {\n                                // this means there weren't enough keys\n                                resolve(null);\n                                return;\n                            }\n                            if (n === 0) {\n                                // We have the first key, return it if that's what they\n                                // wanted.\n                                resolve(cursor.key);\n                            } else {\n                                if (!advanced) {\n                                    // Otherwise, ask the cursor to skip ahead n\n                                    // records.\n                                    advanced = true;\n                                    cursor.advance(n);\n                                } else {\n                                    // When we get here, we've got the nth key.\n                                    resolve(cursor.key);\n                                }\n                            }\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function keys(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.openKeyCursor();\n                        var keys = [];\n                        req.onsuccess = function () {\n                            var cursor = req.result;\n                            if (!cursor) {\n                                resolve(keys);\n                                return;\n                            }\n                            keys.push(cursor.key);\n                            cursor.continue();\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function dropInstance(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        var currentConfig = this.config();\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n            promise = Promise.reject('Invalid arguments');\n        } else {\n            const isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n            const dbPromise = isCurrentDb ? Promise.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(db => {\n                const dbContext = dbContexts[options.name];\n                const forages = dbContext.forages;\n                dbContext.db = db;\n                for (var i = 0; i < forages.length; i++) {\n                    forages[i]._dbInfo.db = db;\n                }\n                return db;\n            });\n            if (!options.storeName) {\n                promise = dbPromise.then(db => {\n                    _deferReadiness(options);\n                    const dbContext = dbContexts[options.name];\n                    const forages = dbContext.forages;\n                    db.close();\n                    for (var i = 0; i < forages.length; i++) {\n                        const forage = forages[i];\n                        forage._dbInfo.db = null;\n                    }\n                    const dropDBPromise = new Promise((resolve, reject) => {\n                        var req = idb.deleteDatabase(options.name);\n                        req.onerror = () => {\n                            const db = req.result;\n                            if (db) {\n                                db.close();\n                            }\n                            reject(req.error);\n                        };\n                        req.onblocked = () => {\n                            // Closing all open connections in onversionchange handler should prevent this situation, but if\n                            // we do get here, it just means the request remains pending - eventually it will succeed or error\n                            console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                        };\n                        req.onsuccess = () => {\n                            const db = req.result;\n                            if (db) {\n                                db.close();\n                            }\n                            resolve(db);\n                        };\n                    });\n                    return dropDBPromise.then(db => {\n                        dbContext.db = db;\n                        for (var i = 0; i < forages.length; i++) {\n                            const forage = forages[i];\n                            _advanceReadiness(forage._dbInfo);\n                        }\n                    }).catch(err => {\n                        (_rejectReadiness(options, err) || Promise.resolve()).catch(() => {\n                        });\n                        throw err;\n                    });\n                });\n            } else {\n                promise = dbPromise.then(db => {\n                    if (!db.objectStoreNames.contains(options.storeName)) {\n                        return;\n                    }\n                    const newVersion = db.version + 1;\n                    _deferReadiness(options);\n                    const dbContext = dbContexts[options.name];\n                    const forages = dbContext.forages;\n                    db.close();\n                    for (let i = 0; i < forages.length; i++) {\n                        const forage = forages[i];\n                        forage._dbInfo.db = null;\n                        forage._dbInfo.version = newVersion;\n                    }\n                    const dropObjectPromise = new Promise((resolve, reject) => {\n                        const req = idb.open(options.name, newVersion);\n                        req.onerror = err => {\n                            const db = req.result;\n                            db.close();\n                            reject(err);\n                        };\n                        req.onupgradeneeded = () => {\n                            var db = req.result;\n                            db.deleteObjectStore(options.storeName);\n                        };\n                        req.onsuccess = () => {\n                            const db = req.result;\n                            db.close();\n                            resolve(db);\n                        };\n                    });\n                    return dropObjectPromise.then(db => {\n                        dbContext.db = db;\n                        for (let j = 0; j < forages.length; j++) {\n                            const forage = forages[j];\n                            forage._dbInfo.db = db;\n                            _advanceReadiness(forage._dbInfo);\n                        }\n                    }).catch(err => {\n                        (_rejectReadiness(options, err) || Promise.resolve()).catch(() => {\n                        });\n                        throw err;\n                    });\n                });\n            }\n        }\n        executeCallback(promise, callback);\n        return promise;\n    }\n    var asyncStorage = {\n        _driver: 'asyncStorage',\n        _initStorage: _initStorage,\n        _support: isIndexedDBValid(),\n        iterate: iterate,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys,\n        dropInstance: dropInstance\n    };\n    return asyncStorage;\n});"]}