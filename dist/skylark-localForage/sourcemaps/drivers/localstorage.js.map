{"version":3,"sources":["drivers/localstorage.js"],"names":["define","isLocalStorageValid","serializer","Promise","executeCallback","normalizeKey","getCallback","_getKeyPrefix","options","defaultConfig","keyPrefix","name","storeName","_isLocalStorageUsable","localStorage","setItem","removeItem","e","checkIfLocalStorageThrows","length","_driver","_initStorage","dbInfo","i","this","_defaultConfig","_dbInfo","resolve","reject","_support","iterate","iterator","callback","self","promise","ready","then","keyPrefixLength","iterationNumber","key","indexOf","value","getItem","deserialize","substring","result","undefined","originalValue","serialize","error","clear","keys","n","itemKey","push","dropInstance","apply","arguments","currentConfig","config"],"mappings":";;;;;;;AAAAA,QACI,+BACA,sBACA,mBACA,2BACA,wBACA,wBACD,SAAUC,EAAqBC,EAAYC,EAASC,EAAiBC,EAAcC,GAClF,aACA,SAASC,EAAcC,EAASC,GAC5B,IAAIC,EAAYF,EAAQG,KAAO,IAI/B,OAHIH,EAAQI,YAAcH,EAAcG,YACpCF,GAAaF,EAAQI,UAAY,KAE9BF,EAoBX,SAASG,IACL,OAlBJ,WAEI,IAGI,OAFAC,aAAaC,QAFS,6BAEoB,GAC1CD,aAAaE,WAHS,8BAIf,EACT,MAAOC,GACL,OAAO,GAWHC,IAA+BJ,aAAaK,OAAS,EA2PjE,OAbIC,QAAS,sBACTC,aA5OJ,SAAsBb,GAClB,IACIc,KACJ,GAAId,EACA,IAAK,IAAIe,KAAKf,EACVc,EAAOC,GAAKf,EAAQe,GAI5B,OADAD,EAAOZ,UAAYH,EAAcC,EAPtBgB,KAOoCC,gBAC1CZ,KARMW,KAWNE,QAAUJ,EACfA,EAAOpB,WAAaA,EACbC,EAAQwB,WAJJxB,EAAQyB,UAmOnBC,SAAU5B,IACV6B,QAlLJ,SAAiBC,EAAUC,GACvB,IAAIC,EAAOT,KACPU,EAAUD,EAAKE,QAAQC,KAAK,WAiB5B,IAhBA,IAAId,EAASW,EAAKP,QACdhB,EAAYY,EAAOZ,UACnB2B,EAAkB3B,EAAUS,OAC5BA,EAASL,aAAaK,OAYtBmB,EAAkB,EACbf,EAAI,EAAGA,EAAIJ,EAAQI,IAAK,CAC7B,IAAIgB,EAAMzB,aAAayB,IAAIhB,GAC3B,GAA+B,IAA3BgB,EAAIC,QAAQ9B,GAAhB,CAGA,IAAI+B,EAAQ3B,aAAa4B,QAAQH,GAYjC,GAJIE,IACAA,EAAQnB,EAAOpB,WAAWyC,YAAYF,SAG5B,KADdA,EAAQV,EAASU,EAAOF,EAAIK,UAAUP,GAAkBC,MAEpD,OAAOG,MAKnB,OADArC,EAAgB8B,EAASF,GAClBE,GAyIPQ,QAzMJ,SAAiBH,EAAKP,GAClB,IAAIC,EAAOT,KACXe,EAAMlC,EAAakC,GACnB,IAAIL,EAAUD,EAAKE,QAAQC,KAAK,WAC5B,IAAId,EAASW,EAAKP,QACdmB,EAAS/B,aAAa4B,QAAQpB,EAAOZ,UAAY6B,GAWrD,OAHIM,IACAA,EAASvB,EAAOpB,WAAWyC,YAAYE,IAEpCA,IAGX,OADAzC,EAAgB8B,EAASF,GAClBE,GAuLPnB,QAxEJ,SAAiBwB,EAAKE,EAAOT,GACzB,IAAIC,EAAOT,KACXe,EAAMlC,EAAakC,GACnB,IAAIL,EAAUD,EAAKE,QAAQC,KAAK,gBAGdU,IAAVL,IACAA,EAAQ,MAGZ,IAAIM,EAAgBN,EACpB,OAAO,IAAItC,EAAQ,SAAUwB,EAASC,GAClC,IAAIN,EAASW,EAAKP,QAClBJ,EAAOpB,WAAW8C,UAAUP,EAAO,SAAUA,EAAOQ,GAChD,GAAIA,EACArB,EAAOqB,QAEP,IACInC,aAAaC,QAAQO,EAAOZ,UAAY6B,EAAKE,GAC7Cd,EAAQoB,GACV,MAAO9B,GAGU,uBAAXA,EAAEN,MAA4C,+BAAXM,EAAEN,MACrCiB,EAAOX,GAEXW,EAAOX,UAO3B,OADAb,EAAgB8B,EAASF,GAClBE,GAwCPlB,WA1FJ,SAAoBuB,EAAKP,GACrB,IAAIC,EAAOT,KACXe,EAAMlC,EAAakC,GACnB,IAAIL,EAAUD,EAAKE,QAAQC,KAAK,WAC5B,IAAId,EAASW,EAAKP,QAClBZ,aAAaE,WAAWM,EAAOZ,UAAY6B,KAG/C,OADAnC,EAAgB8B,EAASF,GAClBE,GAmFPgB,MA/NJ,SAAelB,GACX,IAAIC,EAAOT,KACPU,EAAUD,EAAKE,QAAQC,KAAK,WAE5B,IADA,IAAI1B,EAAYuB,EAAKP,QAAQhB,UACpBa,EAAIT,aAAaK,OAAS,EAAGI,GAAK,EAAGA,IAAK,CAC/C,IAAIgB,EAAMzB,aAAayB,IAAIhB,GACI,IAA3BgB,EAAIC,QAAQ9B,IACZI,aAAaE,WAAWuB,MAKpC,OADAnC,EAAgB8B,EAASF,GAClBE,GAoNPf,OArGJ,SAAgBa,GACZ,IACIE,EADOV,KACQ2B,OAAOf,KAAK,SAAUe,GACrC,OAAOA,EAAKhC,SAGhB,OADAf,EAAgB8B,EAASF,GAClBE,GAgGPK,IA3IJ,SAAaa,EAAGpB,GACZ,IAAIC,EAAOT,KACPU,EAAUD,EAAKE,QAAQC,KAAK,WAC5B,IACIS,EADAvB,EAASW,EAAKP,QAElB,IACImB,EAAS/B,aAAayB,IAAIa,GAC5B,MAAOH,GACLJ,EAAS,KAMb,OAHIA,IACAA,EAASA,EAAOD,UAAUtB,EAAOZ,UAAUS,SAExC0B,IAGX,OADAzC,EAAgB8B,EAASF,GAClBE,GA2HPiB,KAzHJ,SAAcnB,GACV,IAAIC,EAAOT,KACPU,EAAUD,EAAKE,QAAQC,KAAK,WAI5B,IAHA,IAAId,EAASW,EAAKP,QACdP,EAASL,aAAaK,OACtBgC,KACK5B,EAAI,EAAGA,EAAIJ,EAAQI,IAAK,CAC7B,IAAI8B,EAAUvC,aAAayB,IAAIhB,GACW,IAAtC8B,EAAQb,QAAQlB,EAAOZ,YACvByC,EAAKG,KAAKD,EAAQT,UAAUtB,EAAOZ,UAAUS,SAGrD,OAAOgC,IAGX,OADA/C,EAAgB8B,EAASF,GAClBE,GA2GPqB,aA3CJ,SAAsB/C,EAASwB,GAG3B,GAFAA,EAAW1B,EAAYkD,MAAMhC,KAAMiC,aACnCjD,EAA6B,mBAAZA,GAA0BA,OAC9BG,KAAM,CACf,IAAI+C,EAAgBlC,KAAKmC,SACzBnD,EAAQG,KAAOH,EAAQG,MAAQ+C,EAAc/C,KAC7CH,EAAQI,UAAYJ,EAAQI,WAAa8C,EAAc9C,UAE3D,IACIsB,EADAD,EAAOT,KAqBX,OAhBIU,EAHC1B,EAAQG,KAGC,IAAIR,EAAQ,SAAUwB,GACvBnB,EAAQI,UAGTe,EAAQpB,EAAcC,EAASyB,EAAKR,iBAFpCE,KAAYnB,EAAQG,WAIzByB,KAAK,SAAU1B,GACd,IAAK,IAAIa,EAAIT,aAAaK,OAAS,EAAGI,GAAK,EAAGA,IAAK,CAC/C,IAAIgB,EAAMzB,aAAayB,IAAIhB,GACI,IAA3BgB,EAAIC,QAAQ9B,IACZI,aAAaE,WAAWuB,MAZ1BpC,EAAQyB,OAAO,qBAiB7BxB,EAAgB8B,EAASF,GAClBE","file":"../../drivers/localstorage.js","sourcesContent":["define([\n    '../utils/isLocalStorageValid',\n    '../utils/serializer',\n    '../utils/promise',\n    '../utils/executeCallback',\n    '../utils/normalizeKey',\n    '../utils/getCallback'\n], function (isLocalStorageValid, serializer, Promise, executeCallback, normalizeKey, getCallback) {\n    'use strict';\n    function _getKeyPrefix(options, defaultConfig) {\n        var keyPrefix = options.name + '/';\n        if (options.storeName !== defaultConfig.storeName) {\n            keyPrefix += options.storeName + '/';\n        }\n        return keyPrefix;\n    }    // Check if localStorage throws when saving an item\n    // Check if localStorage throws when saving an item\n    function checkIfLocalStorageThrows() {\n        var localStorageTestKey = '_localforage_support_test';\n        try {\n            localStorage.setItem(localStorageTestKey, true);\n            localStorage.removeItem(localStorageTestKey);\n            return false;\n        } catch (e) {\n            return true;\n        }\n    }    // Check if localStorage is usable and allows to save an item\n         // This method checks if localStorage is usable in Safari Private Browsing\n         // mode, or in any other case where the available quota for localStorage\n         // is 0 and there wasn't any saved items yet.\n    // Check if localStorage is usable and allows to save an item\n    // This method checks if localStorage is usable in Safari Private Browsing\n    // mode, or in any other case where the available quota for localStorage\n    // is 0 and there wasn't any saved items yet.\n    function _isLocalStorageUsable() {\n        return !checkIfLocalStorageThrows() || localStorage.length > 0;\n    }    // Config the localStorage backend, using options set in the config.\n    // Config the localStorage backend, using options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = {};\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = options[i];\n            }\n        }\n        dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n        if (!_isLocalStorageUsable()) {\n            return Promise.reject();\n        }\n        self._dbInfo = dbInfo;\n        dbInfo.serializer = serializer;\n        return Promise.resolve();\n    }    // Remove all keys from the datastore, effectively destroying all data in\n         // the app's key/value store!\n    // Remove all keys from the datastore, effectively destroying all data in\n    // the app's key/value store!\n    function clear(callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n            var keyPrefix = self._dbInfo.keyPrefix;\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Retrieve an item from the store. Unlike the original async_storage\n         // library in Gaia, we don't modify return values at all. If a key's value\n         // is `undefined`, we pass that value to the callback function.\n    // Retrieve an item from the store. Unlike the original async_storage\n    // library in Gaia, we don't modify return values at all. If a key's value\n    // is `undefined`, we pass that value to the callback function.\n    function getItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var result = localStorage.getItem(dbInfo.keyPrefix + key);    // If a result was found, parse it from the serialized\n                                                                          // string into a JS object. If result isn't truthy, the key\n                                                                          // is likely undefined and we'll pass it straight to the\n                                                                          // callback.\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the key\n            // is likely undefined and we'll pass it straight to the\n            // callback.\n            if (result) {\n                result = dbInfo.serializer.deserialize(result);\n            }\n            return result;\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Iterate over all items in the store.\n    // Iterate over all items in the store.\n    function iterate(iterator, callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var keyPrefix = dbInfo.keyPrefix;\n            var keyPrefixLength = keyPrefix.length;\n            var length = localStorage.length;    // We use a dedicated iterator instead of the `i` variable below\n                                                 // so other keys we fetch in localStorage aren't counted in\n                                                 // the `iterationNumber` argument passed to the `iterate()`\n                                                 // callback.\n                                                 //\n                                                 // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n            // We use a dedicated iterator instead of the `i` variable below\n            // so other keys we fetch in localStorage aren't counted in\n            // the `iterationNumber` argument passed to the `iterate()`\n            // callback.\n            //\n            // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n            var iterationNumber = 1;\n            for (var i = 0; i < length; i++) {\n                var key = localStorage.key(i);\n                if (key.indexOf(keyPrefix) !== 0) {\n                    continue;\n                }\n                var value = localStorage.getItem(key);    // If a result was found, parse it from the serialized\n                                                          // string into a JS object. If result isn't truthy, the\n                                                          // key is likely undefined and we'll pass it straight\n                                                          // to the iterator.\n                // If a result was found, parse it from the serialized\n                // string into a JS object. If result isn't truthy, the\n                // key is likely undefined and we'll pass it straight\n                // to the iterator.\n                if (value) {\n                    value = dbInfo.serializer.deserialize(value);\n                }\n                value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n                if (value !== void 0) {\n                    return value;\n                }\n            }\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Same as localStorage's key() method, except takes a callback.\n    // Same as localStorage's key() method, except takes a callback.\n    function key(n, callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var result;\n            try {\n                result = localStorage.key(n);\n            } catch (error) {\n                result = null;\n            }    // Remove the prefix from the key, if a key is found.\n            // Remove the prefix from the key, if a key is found.\n            if (result) {\n                result = result.substring(dbInfo.keyPrefix.length);\n            }\n            return result;\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function keys(callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var length = localStorage.length;\n            var keys = [];\n            for (var i = 0; i < length; i++) {\n                var itemKey = localStorage.key(i);\n                if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                    keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n                }\n            }\n            return keys;\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Supply the number of keys in the datastore to the callback function.\n    // Supply the number of keys in the datastore to the callback function.\n    function length(callback) {\n        var self = this;\n        var promise = self.keys().then(function (keys) {\n            return keys.length;\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Remove an item from the store, nice and simple.\n    // Remove an item from the store, nice and simple.\n    function removeItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            localStorage.removeItem(dbInfo.keyPrefix + key);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Set a key's value and run an optional callback once the value is set.\n         // Unlike Gaia's implementation, the callback function is passed the value,\n         // in case you want to operate on that value only after you're sure it\n         // saved, or something like that.\n    // Set a key's value and run an optional callback once the value is set.\n    // Unlike Gaia's implementation, the callback function is passed the value,\n    // in case you want to operate on that value only after you're sure it\n    // saved, or something like that.\n    function setItem(key, value, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n            // Convert undefined values to null.\n            // https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }    // Save the original value to pass to the callback.\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n            return new Promise(function (resolve, reject) {\n                var dbInfo = self._dbInfo;\n                dbInfo.serializer.serialize(value, function (value, error) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        try {\n                            localStorage.setItem(dbInfo.keyPrefix + key, value);\n                            resolve(originalValue);\n                        } catch (e) {\n                            // localStorage capacity exceeded.\n                            // TODO: Make this a specific error/event.\n                            if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                                reject(e);\n                            }\n                            reject(e);\n                        }\n                    }\n                });\n            });\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function dropInstance(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n            var currentConfig = this.config();\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n            promise = Promise.reject('Invalid arguments');\n        } else {\n            promise = new Promise(function (resolve) {\n                if (!options.storeName) {\n                    resolve(`${ options.name }/`);\n                } else {\n                    resolve(_getKeyPrefix(options, self._defaultConfig));\n                }\n            }).then(function (keyPrefix) {\n                for (var i = localStorage.length - 1; i >= 0; i--) {\n                    var key = localStorage.key(i);\n                    if (key.indexOf(keyPrefix) === 0) {\n                        localStorage.removeItem(key);\n                    }\n                }\n            });\n        }\n        executeCallback(promise, callback);\n        return promise;\n    }\n    var localStorageWrapper = {\n        _driver: 'localStorageWrapper',\n        _initStorage: _initStorage,\n        _support: isLocalStorageValid(),\n        iterate: iterate,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys,\n        dropInstance: dropInstance\n    };\n    return localStorageWrapper;\n});"]}