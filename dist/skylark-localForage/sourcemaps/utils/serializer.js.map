{"version":3,"sources":["utils/serializer.js"],"names":["define","createBlob","BASE_CHARS","BLOB_TYPE_PREFIX","BLOB_TYPE_PREFIX_REGEX","SERIALIZED_MARKER","SERIALIZED_MARKER_LENGTH","length","TYPE_ARRAYBUFFER","TYPE_BLOB","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT16ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","TYPE_SERIALIZED_MARKER_LENGTH","toString","Object","prototype","stringToBuffer","serializedString","i","encoded1","encoded2","encoded3","encoded4","bufferLength","len","p","buffer","ArrayBuffer","bytes","Uint8Array","indexOf","bufferToString","base64String","substring","serialize","value","callback","valueType","call","marker","Error","fileReader","FileReader","onload","str","type","this","result","readAsArrayBuffer","JSON","stringify","e","console","error","deserialize","parse","blobType","test","matcher","match","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"],"mappings":"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","file":"../../utils/serializer.js","sourcesContent":["define(['./createBlob'], function (createBlob) {\n    'use strict';\n    // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n    // it to Base64, so this is how we store it to prevent very strange errors with less\n    // verbose ways of binary <-> string data storage.\n    var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var BLOB_TYPE_PREFIX = '~~local_forage_type~';\n    var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n    var SERIALIZED_MARKER = '__lfsc__:';\n    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;    // OMG the serializations!\n    // OMG the serializations!\n    var TYPE_ARRAYBUFFER = 'arbf';\n    var TYPE_BLOB = 'blob';\n    var TYPE_INT8ARRAY = 'si08';\n    var TYPE_UINT8ARRAY = 'ui08';\n    var TYPE_UINT8CLAMPEDARRAY = 'uic8';\n    var TYPE_INT16ARRAY = 'si16';\n    var TYPE_INT32ARRAY = 'si32';\n    var TYPE_UINT16ARRAY = 'ur16';\n    var TYPE_UINT32ARRAY = 'ui32';\n    var TYPE_FLOAT32ARRAY = 'fl32';\n    var TYPE_FLOAT64ARRAY = 'fl64';\n    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n    var toString = Object.prototype.toString;\n    function stringToBuffer(serializedString) {\n        // Fill the string into a ArrayBuffer.\n        var bufferLength = serializedString.length * 0.75;\n        var len = serializedString.length;\n        var i;\n        var p = 0;\n        var encoded1, encoded2, encoded3, encoded4;\n        if (serializedString[serializedString.length - 1] === '=') {\n            bufferLength--;\n            if (serializedString[serializedString.length - 2] === '=') {\n                bufferLength--;\n            }\n        }\n        var buffer = new ArrayBuffer(bufferLength);\n        var bytes = new Uint8Array(buffer);\n        for (i = 0; i < len; i += 4) {\n            encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);    /*jslint bitwise: true */\n            /*jslint bitwise: true */\n            bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n        }\n        return buffer;\n    }    // Converts a buffer to a string to store, serialized, in the backend\n         // storage library.\n    // Converts a buffer to a string to store, serialized, in the backend\n    // storage library.\n    function bufferToString(buffer) {\n        // base64-arraybuffer\n        var bytes = new Uint8Array(buffer);\n        var base64String = '';\n        var i;\n        for (i = 0; i < bytes.length; i += 3) {\n            /*jslint bitwise: true */\n            base64String += BASE_CHARS[bytes[i] >> 2];\n            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n            base64String += BASE_CHARS[bytes[i + 2] & 63];\n        }\n        if (bytes.length % 3 === 2) {\n            base64String = base64String.substring(0, base64String.length - 1) + '=';\n        } else if (bytes.length % 3 === 1) {\n            base64String = base64String.substring(0, base64String.length - 2) + '==';\n        }\n        return base64String;\n    }    // Serialize a value, afterwards executing a callback (which usually\n         // instructs the `setItem()` callback/promise to be executed). This is how\n         // we store binary data with localStorage.\n    // Serialize a value, afterwards executing a callback (which usually\n    // instructs the `setItem()` callback/promise to be executed). This is how\n    // we store binary data with localStorage.\n    function serialize(value, callback) {\n        var valueType = '';\n        if (value) {\n            valueType = toString.call(value);\n        }    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n             // checks fail when running the tests using casper.js...\n             //\n             // TODO: See why those tests fail and use a better solution.\n        // Cannot use `value instanceof ArrayBuffer` or such here, as these\n        // checks fail when running the tests using casper.js...\n        //\n        // TODO: See why those tests fail and use a better solution.\n        if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString.call(value.buffer) === '[object ArrayBuffer]')) {\n            // Convert binary arrays to a string and prefix the string with\n            // a special marker.\n            var buffer;\n            var marker = SERIALIZED_MARKER;\n            if (value instanceof ArrayBuffer) {\n                buffer = value;\n                marker += TYPE_ARRAYBUFFER;\n            } else {\n                buffer = value.buffer;\n                if (valueType === '[object Int8Array]') {\n                    marker += TYPE_INT8ARRAY;\n                } else if (valueType === '[object Uint8Array]') {\n                    marker += TYPE_UINT8ARRAY;\n                } else if (valueType === '[object Uint8ClampedArray]') {\n                    marker += TYPE_UINT8CLAMPEDARRAY;\n                } else if (valueType === '[object Int16Array]') {\n                    marker += TYPE_INT16ARRAY;\n                } else if (valueType === '[object Uint16Array]') {\n                    marker += TYPE_UINT16ARRAY;\n                } else if (valueType === '[object Int32Array]') {\n                    marker += TYPE_INT32ARRAY;\n                } else if (valueType === '[object Uint32Array]') {\n                    marker += TYPE_UINT32ARRAY;\n                } else if (valueType === '[object Float32Array]') {\n                    marker += TYPE_FLOAT32ARRAY;\n                } else if (valueType === '[object Float64Array]') {\n                    marker += TYPE_FLOAT64ARRAY;\n                } else {\n                    callback(new Error('Failed to get type for BinaryArray'));\n                }\n            }\n            callback(marker + bufferToString(buffer));\n        } else if (valueType === '[object Blob]') {\n            // Conver the blob to a binaryArray and then to a string.\n            var fileReader = new FileReader();\n            fileReader.onload = function () {\n                // Backwards-compatible prefix for the blob type.\n                var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n                callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n            };\n            fileReader.readAsArrayBuffer(value);\n        } else {\n            try {\n                callback(JSON.stringify(value));\n            } catch (e) {\n                console.error(\"Couldn't convert value into a JSON string: \", value);\n                callback(null, e);\n            }\n        }\n    }    // Deserialize data we've inserted into a value column/field. We place\n         // special markers into our strings to mark them as encoded; this isn't\n         // as nice as a meta field, but it's the only sane thing we can do whilst\n         // keeping localStorage support intact.\n         //\n         // Oftentimes this will just deserialize JSON content, but if we have a\n         // special marker (SERIALIZED_MARKER, defined above), we will extract\n         // some kind of arraybuffer/binary data/typed array out of the string.\n    // Deserialize data we've inserted into a value column/field. We place\n    // special markers into our strings to mark them as encoded; this isn't\n    // as nice as a meta field, but it's the only sane thing we can do whilst\n    // keeping localStorage support intact.\n    //\n    // Oftentimes this will just deserialize JSON content, but if we have a\n    // special marker (SERIALIZED_MARKER, defined above), we will extract\n    // some kind of arraybuffer/binary data/typed array out of the string.\n    function deserialize(value) {\n        // If we haven't marked this string as being specially serialized (i.e.\n        // something other than serialized JSON), we can just return it and be\n        // done with it.\n        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n            return JSON.parse(value);\n        }    // The following code deals with deserializing some kind of Blob or\n             // TypedArray. First we separate out the type of data we're dealing\n             // with from the data itself.\n        // The following code deals with deserializing some kind of Blob or\n        // TypedArray. First we separate out the type of data we're dealing\n        // with from the data itself.\n        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n        var blobType;    // Backwards-compatible blob type serialization strategy.\n                         // DBs created with older versions of localForage will simply not have the blob type.\n        // Backwards-compatible blob type serialization strategy.\n        // DBs created with older versions of localForage will simply not have the blob type.\n        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n            blobType = matcher[1];\n            serializedString = serializedString.substring(matcher[0].length);\n        }\n        var buffer = stringToBuffer(serializedString);    // Return the right type based on the code/type set during\n                                                          // serialization.\n        // Return the right type based on the code/type set during\n        // serialization.\n        switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n        }\n    }\n    var localforageSerializer = {\n        serialize: serialize,\n        deserialize: deserialize,\n        stringToBuffer: stringToBuffer,\n        bufferToString: bufferToString\n    };\n    return localforageSerializer;\n});"]}