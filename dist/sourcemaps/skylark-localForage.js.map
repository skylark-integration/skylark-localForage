{"version":3,"sources":["skylark-localForage.js"],"names":["define","idb","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","e","getIDB","open","isSafari","openDatabase","test","navigator","userAgent","platform","hasFetch","fetch","toString","indexOf","IDBKeyRange","parts","properties","Blob","name","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","i","length","append","getBlob","type","Promise","promise","callback","then","result","error","errorCallback","catch","key","console","warn","String","arguments","isIndexedDBValid","createBlob","executeCallback","executeTwoCallbacks","normalizeKey","getCallback","DETECT_BLOB_SUPPORT_STORE","supportsBlobs","dbContexts","Object","prototype","READ_ONLY","READ_WRITE","_checkBlobSupport","resolve","txn","transaction","blob","objectStore","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","match","matchedEdge","parseInt","_checkBlobSupportWithoutCaching","value","_deferReadiness","dbInfo","dbContext","deferredOperation","reject","deferredOperations","push","dbReady","_advanceReadiness","pop","_rejectReadiness","err","_getConnection","upgradeNeeded","forages","db","close","dbArgs","version","openreq","apply","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","newVersion","onerror","onsuccess","onversionchange","target","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_decodeBlob","encodedBlob","arrayBuff","bin","buf","ArrayBuffer","arr","Uint8Array","charCodeAt","_binStringToArrayBuffer","atob","data","_isEncodedBlob","__local_forage_encoded_blob","_fullyReady","self","this","_initReady","_dbInfo","createTransaction","mode","retries","undefined","tx","forage","_tryReconnect","asyncStorage","_driver","_initStorage","options","ready","initPromises","ignoreErrors","j","slice","all","_defaultConfig","k","_support","iterate","iterator","store","req","openCursor","iterationNumber","cursor","continue","getItem","get","setItem","call","blobSupport","reader","FileReader","onloadend","base64","btoa","readAsBinaryString","removeItem","delete","clear","count","n","advanced","openKeyCursor","advance","keys","dropInstance","currentConfig","config","isCurrentDb","dbPromise","dropObjectPromise","deleteObjectStore","dropDBPromise","deleteDatabase","onblocked","BASE_CHARS","BLOB_TYPE_PREFIX","BLOB_TYPE_PREFIX_REGEX","SERIALIZED_MARKER","SERIALIZED_MARKER_LENGTH","TYPE_ARRAYBUFFER","TYPE_BLOB","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT16ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","TYPE_SERIALIZED_MARKER_LENGTH","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","len","p","buffer","bytes","bufferToString","base64String","substring","localforageSerializer","serialize","valueType","marker","Error","fileReader","onload","str","readAsArrayBuffer","JSON","stringify","deserialize","parse","blobType","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","isWebSQLValid","serializer","createDbTable","t","executeSql","tryExecuteSql","sqlStatement","args","code","SYNTAX_ERR","results","rows","webSQLStorage","dbInfoPromise","description","size","item","_setItem","retriesLeft","originalValue","sqlError","QUOTA_ERR","c","storeNames","getAllStoreNames","operationInfo","dropTable","operations","localStorage","isLocalStorageValid","_getKeyPrefix","defaultConfig","keyPrefix","_isLocalStorageUsable","checkIfLocalStorageThrows","localStorageWrapper","keyPrefixLength","itemKey","sameValue","x","y","isNaN","array","searchElement","isArray","Array","arg","idbDriver","websqlDriver","localstorageDriver","includes","DefinedDrivers","DriverSupport","DefaultDrivers","INDEXEDDB","WEBSQL","LOCALSTORAGE","DefaultDriverOrder","OptionalDriverMethods","LibraryMethods","concat","DefaultConfig","driver","callWhenReady","localForageInstance","libraryMethod","_args","extend","hasOwnProperty","LocalForage","[object Object]","driverTypeKey","driverName","defineDriver","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","replace","driverObject","complianceError","driverMethods","driverMethodName","isRequired","configureMissingMethods","methodNotImplementedFactory","methodName","optionalDriverMethod","setDriverSupport","support","info","getDriverPromise","serializerPromise","drivers","supportedDrivers","_getSupportedDrivers","setDriverToConfig","extendSelfWithDriver","_extend","oldDriverSetDone","getDriver","currentDriverIndex","driverPromiseLoop","initDriver","libraryMethodsAndProperties","supports","skylark","localforage","attach","main"],"mappings":"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","file":"../skylark-localForage.js","sourcesContent":["define('skylark-localForage/utils/idb',[],function () {\n    'use strict';\n    function getIDB() {\n        /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n        try {\n            if (typeof indexedDB !== 'undefined') {\n                return indexedDB;\n            }\n            if (typeof webkitIndexedDB !== 'undefined') {\n                return webkitIndexedDB;\n            }\n            if (typeof mozIndexedDB !== 'undefined') {\n                return mozIndexedDB;\n            }\n            if (typeof OIndexedDB !== 'undefined') {\n                return OIndexedDB;\n            }\n            if (typeof msIndexedDB !== 'undefined') {\n                return msIndexedDB;\n            }\n        } catch (e) {\n            return;\n        }\n    }\n    var idb = getIDB();\n    return idb;\n});\ndefine('skylark-localForage/utils/isIndexedDBValid',['./idb'], function (idb) {\n    'use strict';\n    function isIndexedDBValid() {\n        try {\n            // Initialize IndexedDB; fall back to vendor-prefixed versions\n            // if needed.\n            if (!idb || !idb.open) {\n                return false;\n            }    // We mimic PouchDB here;\n                 //\n                 // We test for openDatabase because IE Mobile identifies itself\n                 // as Safari. Oh the lulz...\n            // We mimic PouchDB here;\n            //\n            // We test for openDatabase because IE Mobile identifies itself\n            // as Safari. Oh the lulz...\n            var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n            var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;    // Safari <10.1 does not meet our requirements for IDB support\n                                                                                                              // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n                                                                                                              // Safari 10.1 shipped with fetch, we can use that to detect it.\n                                                                                                              // Note: this creates issues with `window.fetch` polyfills and\n                                                                                                              // overrides; see:\n                                                                                                              // https://github.com/localForage/localForage/issues/856\n            // Safari <10.1 does not meet our requirements for IDB support\n            // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n            // Safari 10.1 shipped with fetch, we can use that to detect it.\n            // Note: this creates issues with `window.fetch` polyfills and\n            // overrides; see:\n            // https://github.com/localForage/localForage/issues/856\n            return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' && // some outdated implementations of IDB that appear on Samsung\n            // and HTC Android devices <4.4 are missing IDBKeyRange\n            // See: https://github.com/mozilla/localForage/issues/128\n            // See: https://github.com/mozilla/localForage/issues/272\n            typeof IDBKeyRange !== 'undefined';\n        } catch (e) {\n            return false;\n        }\n    }\n    return isIndexedDBValid;\n});\ndefine('skylark-localForage/utils/createBlob',[],function () {\n    'use strict';\n    // Abstracts constructing a Blob object, so it also works in older\n    // browsers that don't support the native Blob constructor. (i.e.\n    // old QtWebKit versions, at least).\n    // Abstracts constructing a Blob object, so it also works in older\n    // browsers that don't support the native Blob constructor. (i.e.\n    // old QtWebKit versions, at least).\n    function createBlob(parts, properties) {\n        /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n        parts = parts || [];\n        properties = properties || {};\n        try {\n            return new Blob(parts, properties);\n        } catch (e) {\n            if (e.name !== 'TypeError') {\n                throw e;\n            }\n            var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n            var builder = new Builder();\n            for (var i = 0; i < parts.length; i += 1) {\n                builder.append(parts[i]);\n            }\n            return builder.getBlob(properties.type);\n        }\n    }\n    return createBlob;\n});\ndefine('skylark-localForage/utils/promise',[],function () {\n    'use strict';\n\n    return Promise;\n});\ndefine('skylark-localForage/utils/executeCallback',[],function () {\n    'use strict';\n    function executeCallback(promise, callback) {\n        if (callback) {\n            promise.then(function (result) {\n                callback(null, result);\n            }, function (error) {\n                callback(error);\n            });\n        }\n    }\n    return executeCallback;\n});\ndefine('skylark-localForage/utils/executeTwoCallbacks',[],function () {\n    'use strict';\n    function executeTwoCallbacks(promise, callback, errorCallback) {\n        if (typeof callback === 'function') {\n            promise.then(callback);\n        }\n        if (typeof errorCallback === 'function') {\n            promise.catch(errorCallback);\n        }\n    }\n    return executeTwoCallbacks;\n});\ndefine('skylark-localForage/utils/normalizeKey',[],function () {\n    'use strict';\n    return function normalizeKey(key) {\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            console.warn(`${ key } used as a key, but it is not a string.`);\n            key = String(key);\n        }\n        return key;\n    };\n});\ndefine('skylark-localForage/utils/getCallback',[],function () {\n    'use strict';\n    return function getCallback() {\n        if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n            return arguments[arguments.length - 1];\n        }\n    };\n});\ndefine('skylark-localForage/drivers/indexeddb',[\n    '../utils/isIndexedDBValid',\n    '../utils/createBlob',\n    '../utils/idb',\n    '../utils/promise',\n    '../utils/executeCallback',\n    '../utils/executeTwoCallbacks',\n    '../utils/normalizeKey',\n    '../utils/getCallback'\n], function (isIndexedDBValid, createBlob, idb, Promise, executeCallback, executeTwoCallbacks, normalizeKey, getCallback) {\n    'use strict';\n    // Some code originally from async_storage.js in\n    // [Gaia](https://github.com/mozilla-b2g/gaia).\n    const DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\n    let supportsBlobs;\n    const dbContexts = {};\n    const toString = Object.prototype.toString;    // Transaction Modes\n    // Transaction Modes\n    const READ_ONLY = 'readonly';\n    const READ_WRITE = 'readwrite';    // Transform a binary string to an array buffer, because otherwise\n                                       // weird stuff happens when you try to work with the binary string directly.\n                                       // It is known.\n                                       // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n                                       // encode-decode-image-with-base64-breaks-image (2013-04-21)\n    // Transform a binary string to an array buffer, because otherwise\n    // weird stuff happens when you try to work with the binary string directly.\n    // It is known.\n    // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n    // encode-decode-image-with-base64-breaks-image (2013-04-21)\n    function _binStringToArrayBuffer(bin) {\n        var length = bin.length;\n        var buf = new ArrayBuffer(length);\n        var arr = new Uint8Array(buf);\n        for (var i = 0; i < length; i++) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return buf;\n    }    //\n         // Blobs are not supported in all versions of IndexedDB, notably\n         // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n         //\n         // Various other blob bugs exist in Chrome v37-42 (inclusive).\n         // Detecting them is expensive and confusing to users, and Chrome 37-42\n         // is at very low usage worldwide, so we do a hacky userAgent check instead.\n         //\n         // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n         // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n         // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n         //\n         // Code borrowed from PouchDB. See:\n         // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n         //\n    //\n    // Blobs are not supported in all versions of IndexedDB, notably\n    // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n    //\n    // Various other blob bugs exist in Chrome v37-42 (inclusive).\n    // Detecting them is expensive and confusing to users, and Chrome 37-42\n    // is at very low usage worldwide, so we do a hacky userAgent check instead.\n    //\n    // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n    // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n    // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n    //\n    // Code borrowed from PouchDB. See:\n    // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n    //\n    function _checkBlobSupportWithoutCaching(idb) {\n        return new Promise(function (resolve) {\n            var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n            var blob = createBlob(['']);\n            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n            txn.onabort = function (e) {\n                // If the transaction aborts now its due to not being able to\n                // write to the database, likely due to the disk being full\n                e.preventDefault();\n                e.stopPropagation();\n                resolve(false);\n            };\n            txn.oncomplete = function () {\n                var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n                var matchedEdge = navigator.userAgent.match(/Edge\\//);    // MS Edge pretends to be Chrome 42:\n                                                                          // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n                // MS Edge pretends to be Chrome 42:\n                // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n                resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n            };\n        }).catch(function () {\n            return false;    // error, so assume unsupported\n        });\n    }\n    // error, so assume unsupported\n    function _checkBlobSupport(idb) {\n        if (typeof supportsBlobs === 'boolean') {\n            return Promise.resolve(supportsBlobs);\n        }\n        return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n            supportsBlobs = value;\n            return supportsBlobs;\n        });\n    }\n    function _deferReadiness(dbInfo) {\n        var dbContext = dbContexts[dbInfo.name];    // Create a deferred object representing the current database operation.\n        // Create a deferred object representing the current database operation.\n        var deferredOperation = {};\n        deferredOperation.promise = new Promise(function (resolve, reject) {\n            deferredOperation.resolve = resolve;\n            deferredOperation.reject = reject;\n        });    // Enqueue the deferred operation.\n        // Enqueue the deferred operation.\n        dbContext.deferredOperations.push(deferredOperation);    // Chain its promise to the database readiness.\n        // Chain its promise to the database readiness.\n        if (!dbContext.dbReady) {\n            dbContext.dbReady = deferredOperation.promise;\n        } else {\n            dbContext.dbReady = dbContext.dbReady.then(function () {\n                return deferredOperation.promise;\n            });\n        }\n    }\n    function _advanceReadiness(dbInfo) {\n        var dbContext = dbContexts[dbInfo.name];    // Dequeue a deferred operation.\n        // Dequeue a deferred operation.\n        var deferredOperation = dbContext.deferredOperations.pop();    // Resolve its promise (which is part of the database readiness\n                                                                       // chain of promises).\n        // Resolve its promise (which is part of the database readiness\n        // chain of promises).\n        if (deferredOperation) {\n            deferredOperation.resolve();\n            return deferredOperation.promise;\n        }\n    }\n    function _rejectReadiness(dbInfo, err) {\n        var dbContext = dbContexts[dbInfo.name];    // Dequeue a deferred operation.\n        // Dequeue a deferred operation.\n        var deferredOperation = dbContext.deferredOperations.pop();    // Reject its promise (which is part of the database readiness\n                                                                       // chain of promises).\n        // Reject its promise (which is part of the database readiness\n        // chain of promises).\n        if (deferredOperation) {\n            deferredOperation.reject(err);\n            return deferredOperation.promise;\n        }\n    }\n    function _getConnection(dbInfo, upgradeNeeded) {\n        return new Promise(function (resolve, reject) {\n            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n            if (dbInfo.db) {\n                if (upgradeNeeded) {\n                    _deferReadiness(dbInfo);\n                    dbInfo.db.close();\n                } else {\n                    return resolve(dbInfo.db);\n                }\n            }\n            var dbArgs = [dbInfo.name];\n            if (upgradeNeeded) {\n                dbArgs.push(dbInfo.version);\n            }\n            var openreq = idb.open.apply(idb, dbArgs);\n            if (upgradeNeeded) {\n                openreq.onupgradeneeded = function (e) {\n                    var db = openreq.result;\n                    try {\n                        db.createObjectStore(dbInfo.storeName);\n                        if (e.oldVersion <= 1) {\n                            // Added when support for blob shims was added\n                            db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                        }\n                    } catch (ex) {\n                        if (ex.name === 'ConstraintError') {\n                            console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                        } else {\n                            throw ex;\n                        }\n                    }\n                };\n            }\n            openreq.onerror = function (e) {\n                e.preventDefault();\n                reject(openreq.error);\n            };\n            openreq.onsuccess = function () {\n                var db = openreq.result;\n                db.onversionchange = function (e) {\n                    // Triggered when the database is modified (e.g. adding an objectStore) or\n                    // deleted (even when initiated by other sessions in different tabs).\n                    // Closing the connection here prevents those operations from being blocked.\n                    // If the database is accessed again later by this instance, the connection\n                    // will be reopened or the database recreated as needed.\n                    e.target.close();\n                };\n                resolve(db);\n                _advanceReadiness(dbInfo);\n            };\n        });\n    }\n    function _getOriginalConnection(dbInfo) {\n        return _getConnection(dbInfo, false);\n    }\n    function _getUpgradedConnection(dbInfo) {\n        return _getConnection(dbInfo, true);\n    }\n    function _isUpgradeNeeded(dbInfo, defaultVersion) {\n        if (!dbInfo.db) {\n            return true;\n        }\n        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n        var isDowngrade = dbInfo.version < dbInfo.db.version;\n        var isUpgrade = dbInfo.version > dbInfo.db.version;\n        if (isDowngrade) {\n            // If the version is not the default one\n            // then warn for impossible downgrade.\n            if (dbInfo.version !== defaultVersion) {\n                console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n            }    // Align the versions to prevent errors.\n            // Align the versions to prevent errors.\n            dbInfo.version = dbInfo.db.version;\n        }\n        if (isUpgrade || isNewStore) {\n            // If the store is new then increment the version (if needed).\n            // This will trigger an \"upgradeneeded\" event which is required\n            // for creating a store.\n            if (isNewStore) {\n                var incVersion = dbInfo.db.version + 1;\n                if (incVersion > dbInfo.version) {\n                    dbInfo.version = incVersion;\n                }\n            }\n            return true;\n        }\n        return false;\n    }    // encode a blob for indexeddb engines that don't support blobs\n    // encode a blob for indexeddb engines that don't support blobs\n    function _encodeBlob(blob) {\n        return new Promise(function (resolve, reject) {\n            var reader = new FileReader();\n            reader.onerror = reject;\n            reader.onloadend = function (e) {\n                var base64 = btoa(e.target.result || '');\n                resolve({\n                    __local_forage_encoded_blob: true,\n                    data: base64,\n                    type: blob.type\n                });\n            };\n            reader.readAsBinaryString(blob);\n        });\n    }    // decode an encoded blob\n    // decode an encoded blob\n    function _decodeBlob(encodedBlob) {\n        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n        return createBlob([arrayBuff], { type: encodedBlob.type });\n    }    // is this one of our fancy encoded blobs?\n    // is this one of our fancy encoded blobs?\n    function _isEncodedBlob(value) {\n        return value && value.__local_forage_encoded_blob;\n    }    // Specialize the default `ready()` function by making it dependent\n         // on the current database operations. Thus, the driver will be actually\n         // ready when it's been initialized (default) *and* there are no pending\n         // operations on the database (initiated by some other instances).\n    // Specialize the default `ready()` function by making it dependent\n    // on the current database operations. Thus, the driver will be actually\n    // ready when it's been initialized (default) *and* there are no pending\n    // operations on the database (initiated by some other instances).\n    function _fullyReady(callback) {\n        var self = this;\n        var promise = self._initReady().then(function () {\n            var dbContext = dbContexts[self._dbInfo.name];\n            if (dbContext && dbContext.dbReady) {\n                return dbContext.dbReady;\n            }\n        });\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    }    // Try to establish a new db connection to replace the\n         // current one which is broken (i.e. experiencing\n         // InvalidStateError while creating a transaction).\n    // Try to establish a new db connection to replace the\n    // current one which is broken (i.e. experiencing\n    // InvalidStateError while creating a transaction).\n    function _tryReconnect(dbInfo) {\n        _deferReadiness(dbInfo);\n        var dbContext = dbContexts[dbInfo.name];\n        var forages = dbContext.forages;\n        for (var i = 0; i < forages.length; i++) {\n            const forage = forages[i];\n            if (forage._dbInfo.db) {\n                forage._dbInfo.db.close();\n                forage._dbInfo.db = null;\n            }\n        }\n        dbInfo.db = null;\n        return _getOriginalConnection(dbInfo).then(db => {\n            dbInfo.db = db;\n            if (_isUpgradeNeeded(dbInfo)) {\n                // Reopen the database for upgrading.\n                return _getUpgradedConnection(dbInfo);\n            }\n            return db;\n        }).then(db => {\n            // store the latest db reference\n            // in case the db was upgraded\n            dbInfo.db = dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n        }).catch(err => {\n            _rejectReadiness(dbInfo, err);\n            throw err;\n        });\n    }    // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n         // so we have to do it with callbacks\n    // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n    // so we have to do it with callbacks\n    function createTransaction(dbInfo, mode, callback, retries) {\n        if (retries === undefined) {\n            retries = 1;\n        }\n        try {\n            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n            callback(null, tx);\n        } catch (err) {\n            if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n                return Promise.resolve().then(() => {\n                    if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                        // increase the db version, to create the new ObjectStore\n                        if (dbInfo.db) {\n                            dbInfo.version = dbInfo.db.version + 1;\n                        }    // Reopen the database for upgrading.\n                        // Reopen the database for upgrading.\n                        return _getUpgradedConnection(dbInfo);\n                    }\n                }).then(() => {\n                    return _tryReconnect(dbInfo).then(function () {\n                        createTransaction(dbInfo, mode, callback, retries - 1);\n                    });\n                }).catch(callback);\n            }\n            callback(err);\n        }\n    }\n    function createDbContext() {\n        return {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n    }    // Open the IndexedDB database (automatically creates one if one didn't\n         // previously exist), using any options set in the config.\n    // Open the IndexedDB database (automatically creates one if one didn't\n    // previously exist), using any options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = { db: null };\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = options[i];\n            }\n        }    // Get the current context of the database;\n        // Get the current context of the database;\n        var dbContext = dbContexts[dbInfo.name];    // ...or create a new context.\n        // ...or create a new context.\n        if (!dbContext) {\n            dbContext = createDbContext();    // Register the new context in the global container.\n            // Register the new context in the global container.\n            dbContexts[dbInfo.name] = dbContext;\n        }    // Register itself as a running localForage in the current context.\n        // Register itself as a running localForage in the current context.\n        dbContext.forages.push(self);    // Replace the default `ready()` function with the specialized one.\n        // Replace the default `ready()` function with the specialized one.\n        if (!self._initReady) {\n            self._initReady = self.ready;\n            self.ready = _fullyReady;\n        }    // Create an array of initialization states of the related localForages.\n        // Create an array of initialization states of the related localForages.\n        var initPromises = [];\n        function ignoreErrors() {\n            // Don't handle errors here,\n            // just makes sure related localForages aren't pending.\n            return Promise.resolve();\n        }\n        for (var j = 0; j < dbContext.forages.length; j++) {\n            var forage = dbContext.forages[j];\n            if (forage !== self) {\n                // Don't wait for itself...\n                initPromises.push(forage._initReady().catch(ignoreErrors));\n            }\n        }    // Take a snapshot of the related localForages.\n        // Take a snapshot of the related localForages.\n        var forages = dbContext.forages.slice(0);    // Initialize the connection process only when\n                                                     // all the related localForages aren't pending.\n        // Initialize the connection process only when\n        // all the related localForages aren't pending.\n        return Promise.all(initPromises).then(function () {\n            dbInfo.db = dbContext.db;    // Get the connection or open a new one without upgrade.\n            // Get the connection or open a new one without upgrade.\n            return _getOriginalConnection(dbInfo);\n        }).then(function (db) {\n            dbInfo.db = db;\n            if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n                // Reopen the database for upgrading.\n                return _getUpgradedConnection(dbInfo);\n            }\n            return db;\n        }).then(function (db) {\n            dbInfo.db = dbContext.db = db;\n            self._dbInfo = dbInfo;    // Share the final connection amongst related localForages.\n            // Share the final connection amongst related localForages.\n            for (var k = 0; k < forages.length; k++) {\n                var forage = forages[k];\n                if (forage !== self) {\n                    // Self is already up-to-date.\n                    forage._dbInfo.db = dbInfo.db;\n                    forage._dbInfo.version = dbInfo.version;\n                }\n            }\n        });\n    }\n    function getItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.get(key);\n                        req.onsuccess = function () {\n                            var value = req.result;\n                            if (value === undefined) {\n                                value = null;\n                            }\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            resolve(value);\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Iterate over all items stored in database.\n    // Iterate over all items stored in database.\n    function iterate(iterator, callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.openCursor();\n                        var iterationNumber = 1;\n                        req.onsuccess = function () {\n                            var cursor = req.result;\n                            if (cursor) {\n                                var value = cursor.value;\n                                if (_isEncodedBlob(value)) {\n                                    value = _decodeBlob(value);\n                                }\n                                var result = iterator(value, cursor.key, iterationNumber++);    // when the iterator callback returns any\n                                                                                                // (non-`undefined`) value, then we stop\n                                                                                                // the iteration immediately\n                                // when the iterator callback returns any\n                                // (non-`undefined`) value, then we stop\n                                // the iteration immediately\n                                if (result !== void 0) {\n                                    resolve(result);\n                                } else {\n                                    cursor.continue();\n                                }\n                            } else {\n                                resolve();\n                            }\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function setItem(key, value, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            var dbInfo;\n            self.ready().then(function () {\n                dbInfo = self._dbInfo;\n                if (toString.call(value) === '[object Blob]') {\n                    return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                        if (blobSupport) {\n                            return value;\n                        }\n                        return _encodeBlob(value);\n                    });\n                }\n                return value;\n            }).then(function (value) {\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);    // The reason we don't _save_ null is because IE 10 does\n                                                                                        // not support saving the `null` type in IndexedDB. How\n                                                                                        // ironic, given the bug below!\n                                                                                        // See: https://github.com/mozilla/localForage/issues/161\n                        // The reason we don't _save_ null is because IE 10 does\n                        // not support saving the `null` type in IndexedDB. How\n                        // ironic, given the bug below!\n                        // See: https://github.com/mozilla/localForage/issues/161\n                        if (value === null) {\n                            value = undefined;\n                        }\n                        var req = store.put(value, key);\n                        transaction.oncomplete = function () {\n                            // Cast to undefined so the value passed to\n                            // callback/promise is the same as what one would get out\n                            // of `getItem()` later. This leads to some weirdness\n                            // (setItem('foo', undefined) will return `null`), but\n                            // it's not my fault localStorage is our baseline and that\n                            // it's weird.\n                            if (value === undefined) {\n                                value = null;\n                            }\n                            resolve(value);\n                        };\n                        transaction.onabort = transaction.onerror = function () {\n                            var err = req.error ? req.error : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function removeItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);    // We use a Grunt task to make this safe for IE and some\n                                                                                        // versions of Android (including those used by Cordova).\n                                                                                        // Normally IE won't like `.delete()` and will insist on\n                                                                                        // using `['delete']()`, but we have a build step that\n                                                                                        // fixes this for us now.\n                        // We use a Grunt task to make this safe for IE and some\n                        // versions of Android (including those used by Cordova).\n                        // Normally IE won't like `.delete()` and will insist on\n                        // using `['delete']()`, but we have a build step that\n                        // fixes this for us now.\n                        var req = store.delete(key);\n                        transaction.oncomplete = function () {\n                            resolve();\n                        };\n                        transaction.onerror = function () {\n                            reject(req.error);\n                        };    // The request will be also be aborted if we've exceeded our storage\n                              // space.\n                        // The request will be also be aborted if we've exceeded our storage\n                        // space.\n                        transaction.onabort = function () {\n                            var err = req.error ? req.error : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function clear(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.clear();\n                        transaction.oncomplete = function () {\n                            resolve();\n                        };\n                        transaction.onabort = transaction.onerror = function () {\n                            var err = req.error ? req.error : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function length(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.count();\n                        req.onsuccess = function () {\n                            resolve(req.result);\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function key(n, callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (n < 0) {\n                resolve(null);\n                return;\n            }\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var advanced = false;\n                        var req = store.openKeyCursor();\n                        req.onsuccess = function () {\n                            var cursor = req.result;\n                            if (!cursor) {\n                                // this means there weren't enough keys\n                                resolve(null);\n                                return;\n                            }\n                            if (n === 0) {\n                                // We have the first key, return it if that's what they\n                                // wanted.\n                                resolve(cursor.key);\n                            } else {\n                                if (!advanced) {\n                                    // Otherwise, ask the cursor to skip ahead n\n                                    // records.\n                                    advanced = true;\n                                    cursor.advance(n);\n                                } else {\n                                    // When we get here, we've got the nth key.\n                                    resolve(cursor.key);\n                                }\n                            }\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function keys(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    try {\n                        var store = transaction.objectStore(self._dbInfo.storeName);\n                        var req = store.openKeyCursor();\n                        var keys = [];\n                        req.onsuccess = function () {\n                            var cursor = req.result;\n                            if (!cursor) {\n                                resolve(keys);\n                                return;\n                            }\n                            keys.push(cursor.key);\n                            cursor.continue();\n                        };\n                        req.onerror = function () {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function dropInstance(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        var currentConfig = this.config();\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n            promise = Promise.reject('Invalid arguments');\n        } else {\n            const isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n            const dbPromise = isCurrentDb ? Promise.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(db => {\n                const dbContext = dbContexts[options.name];\n                const forages = dbContext.forages;\n                dbContext.db = db;\n                for (var i = 0; i < forages.length; i++) {\n                    forages[i]._dbInfo.db = db;\n                }\n                return db;\n            });\n            if (!options.storeName) {\n                promise = dbPromise.then(db => {\n                    _deferReadiness(options);\n                    const dbContext = dbContexts[options.name];\n                    const forages = dbContext.forages;\n                    db.close();\n                    for (var i = 0; i < forages.length; i++) {\n                        const forage = forages[i];\n                        forage._dbInfo.db = null;\n                    }\n                    const dropDBPromise = new Promise((resolve, reject) => {\n                        var req = idb.deleteDatabase(options.name);\n                        req.onerror = () => {\n                            const db = req.result;\n                            if (db) {\n                                db.close();\n                            }\n                            reject(req.error);\n                        };\n                        req.onblocked = () => {\n                            // Closing all open connections in onversionchange handler should prevent this situation, but if\n                            // we do get here, it just means the request remains pending - eventually it will succeed or error\n                            console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                        };\n                        req.onsuccess = () => {\n                            const db = req.result;\n                            if (db) {\n                                db.close();\n                            }\n                            resolve(db);\n                        };\n                    });\n                    return dropDBPromise.then(db => {\n                        dbContext.db = db;\n                        for (var i = 0; i < forages.length; i++) {\n                            const forage = forages[i];\n                            _advanceReadiness(forage._dbInfo);\n                        }\n                    }).catch(err => {\n                        (_rejectReadiness(options, err) || Promise.resolve()).catch(() => {\n                        });\n                        throw err;\n                    });\n                });\n            } else {\n                promise = dbPromise.then(db => {\n                    if (!db.objectStoreNames.contains(options.storeName)) {\n                        return;\n                    }\n                    const newVersion = db.version + 1;\n                    _deferReadiness(options);\n                    const dbContext = dbContexts[options.name];\n                    const forages = dbContext.forages;\n                    db.close();\n                    for (let i = 0; i < forages.length; i++) {\n                        const forage = forages[i];\n                        forage._dbInfo.db = null;\n                        forage._dbInfo.version = newVersion;\n                    }\n                    const dropObjectPromise = new Promise((resolve, reject) => {\n                        const req = idb.open(options.name, newVersion);\n                        req.onerror = err => {\n                            const db = req.result;\n                            db.close();\n                            reject(err);\n                        };\n                        req.onupgradeneeded = () => {\n                            var db = req.result;\n                            db.deleteObjectStore(options.storeName);\n                        };\n                        req.onsuccess = () => {\n                            const db = req.result;\n                            db.close();\n                            resolve(db);\n                        };\n                    });\n                    return dropObjectPromise.then(db => {\n                        dbContext.db = db;\n                        for (let j = 0; j < forages.length; j++) {\n                            const forage = forages[j];\n                            forage._dbInfo.db = db;\n                            _advanceReadiness(forage._dbInfo);\n                        }\n                    }).catch(err => {\n                        (_rejectReadiness(options, err) || Promise.resolve()).catch(() => {\n                        });\n                        throw err;\n                    });\n                });\n            }\n        }\n        executeCallback(promise, callback);\n        return promise;\n    }\n    var asyncStorage = {\n        _driver: 'asyncStorage',\n        _initStorage: _initStorage,\n        _support: isIndexedDBValid(),\n        iterate: iterate,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys,\n        dropInstance: dropInstance\n    };\n    return asyncStorage;\n});\ndefine('skylark-localForage/utils/isWebSQLValid',[],function () {\n    'use strict';\n    function isWebSQLValid() {\n        return typeof openDatabase === 'function';\n    }\n    return isWebSQLValid;\n});\ndefine('skylark-localForage/utils/serializer',['./createBlob'], function (createBlob) {\n    'use strict';\n    // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n    // it to Base64, so this is how we store it to prevent very strange errors with less\n    // verbose ways of binary <-> string data storage.\n    var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var BLOB_TYPE_PREFIX = '~~local_forage_type~';\n    var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n    var SERIALIZED_MARKER = '__lfsc__:';\n    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;    // OMG the serializations!\n    // OMG the serializations!\n    var TYPE_ARRAYBUFFER = 'arbf';\n    var TYPE_BLOB = 'blob';\n    var TYPE_INT8ARRAY = 'si08';\n    var TYPE_UINT8ARRAY = 'ui08';\n    var TYPE_UINT8CLAMPEDARRAY = 'uic8';\n    var TYPE_INT16ARRAY = 'si16';\n    var TYPE_INT32ARRAY = 'si32';\n    var TYPE_UINT16ARRAY = 'ur16';\n    var TYPE_UINT32ARRAY = 'ui32';\n    var TYPE_FLOAT32ARRAY = 'fl32';\n    var TYPE_FLOAT64ARRAY = 'fl64';\n    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n    var toString = Object.prototype.toString;\n    function stringToBuffer(serializedString) {\n        // Fill the string into a ArrayBuffer.\n        var bufferLength = serializedString.length * 0.75;\n        var len = serializedString.length;\n        var i;\n        var p = 0;\n        var encoded1, encoded2, encoded3, encoded4;\n        if (serializedString[serializedString.length - 1] === '=') {\n            bufferLength--;\n            if (serializedString[serializedString.length - 2] === '=') {\n                bufferLength--;\n            }\n        }\n        var buffer = new ArrayBuffer(bufferLength);\n        var bytes = new Uint8Array(buffer);\n        for (i = 0; i < len; i += 4) {\n            encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);    /*jslint bitwise: true */\n            /*jslint bitwise: true */\n            bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n        }\n        return buffer;\n    }    // Converts a buffer to a string to store, serialized, in the backend\n         // storage library.\n    // Converts a buffer to a string to store, serialized, in the backend\n    // storage library.\n    function bufferToString(buffer) {\n        // base64-arraybuffer\n        var bytes = new Uint8Array(buffer);\n        var base64String = '';\n        var i;\n        for (i = 0; i < bytes.length; i += 3) {\n            /*jslint bitwise: true */\n            base64String += BASE_CHARS[bytes[i] >> 2];\n            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n            base64String += BASE_CHARS[bytes[i + 2] & 63];\n        }\n        if (bytes.length % 3 === 2) {\n            base64String = base64String.substring(0, base64String.length - 1) + '=';\n        } else if (bytes.length % 3 === 1) {\n            base64String = base64String.substring(0, base64String.length - 2) + '==';\n        }\n        return base64String;\n    }    // Serialize a value, afterwards executing a callback (which usually\n         // instructs the `setItem()` callback/promise to be executed). This is how\n         // we store binary data with localStorage.\n    // Serialize a value, afterwards executing a callback (which usually\n    // instructs the `setItem()` callback/promise to be executed). This is how\n    // we store binary data with localStorage.\n    function serialize(value, callback) {\n        var valueType = '';\n        if (value) {\n            valueType = toString.call(value);\n        }    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n             // checks fail when running the tests using casper.js...\n             //\n             // TODO: See why those tests fail and use a better solution.\n        // Cannot use `value instanceof ArrayBuffer` or such here, as these\n        // checks fail when running the tests using casper.js...\n        //\n        // TODO: See why those tests fail and use a better solution.\n        if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString.call(value.buffer) === '[object ArrayBuffer]')) {\n            // Convert binary arrays to a string and prefix the string with\n            // a special marker.\n            var buffer;\n            var marker = SERIALIZED_MARKER;\n            if (value instanceof ArrayBuffer) {\n                buffer = value;\n                marker += TYPE_ARRAYBUFFER;\n            } else {\n                buffer = value.buffer;\n                if (valueType === '[object Int8Array]') {\n                    marker += TYPE_INT8ARRAY;\n                } else if (valueType === '[object Uint8Array]') {\n                    marker += TYPE_UINT8ARRAY;\n                } else if (valueType === '[object Uint8ClampedArray]') {\n                    marker += TYPE_UINT8CLAMPEDARRAY;\n                } else if (valueType === '[object Int16Array]') {\n                    marker += TYPE_INT16ARRAY;\n                } else if (valueType === '[object Uint16Array]') {\n                    marker += TYPE_UINT16ARRAY;\n                } else if (valueType === '[object Int32Array]') {\n                    marker += TYPE_INT32ARRAY;\n                } else if (valueType === '[object Uint32Array]') {\n                    marker += TYPE_UINT32ARRAY;\n                } else if (valueType === '[object Float32Array]') {\n                    marker += TYPE_FLOAT32ARRAY;\n                } else if (valueType === '[object Float64Array]') {\n                    marker += TYPE_FLOAT64ARRAY;\n                } else {\n                    callback(new Error('Failed to get type for BinaryArray'));\n                }\n            }\n            callback(marker + bufferToString(buffer));\n        } else if (valueType === '[object Blob]') {\n            // Conver the blob to a binaryArray and then to a string.\n            var fileReader = new FileReader();\n            fileReader.onload = function () {\n                // Backwards-compatible prefix for the blob type.\n                var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n                callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n            };\n            fileReader.readAsArrayBuffer(value);\n        } else {\n            try {\n                callback(JSON.stringify(value));\n            } catch (e) {\n                console.error(\"Couldn't convert value into a JSON string: \", value);\n                callback(null, e);\n            }\n        }\n    }    // Deserialize data we've inserted into a value column/field. We place\n         // special markers into our strings to mark them as encoded; this isn't\n         // as nice as a meta field, but it's the only sane thing we can do whilst\n         // keeping localStorage support intact.\n         //\n         // Oftentimes this will just deserialize JSON content, but if we have a\n         // special marker (SERIALIZED_MARKER, defined above), we will extract\n         // some kind of arraybuffer/binary data/typed array out of the string.\n    // Deserialize data we've inserted into a value column/field. We place\n    // special markers into our strings to mark them as encoded; this isn't\n    // as nice as a meta field, but it's the only sane thing we can do whilst\n    // keeping localStorage support intact.\n    //\n    // Oftentimes this will just deserialize JSON content, but if we have a\n    // special marker (SERIALIZED_MARKER, defined above), we will extract\n    // some kind of arraybuffer/binary data/typed array out of the string.\n    function deserialize(value) {\n        // If we haven't marked this string as being specially serialized (i.e.\n        // something other than serialized JSON), we can just return it and be\n        // done with it.\n        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n            return JSON.parse(value);\n        }    // The following code deals with deserializing some kind of Blob or\n             // TypedArray. First we separate out the type of data we're dealing\n             // with from the data itself.\n        // The following code deals with deserializing some kind of Blob or\n        // TypedArray. First we separate out the type of data we're dealing\n        // with from the data itself.\n        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n        var blobType;    // Backwards-compatible blob type serialization strategy.\n                         // DBs created with older versions of localForage will simply not have the blob type.\n        // Backwards-compatible blob type serialization strategy.\n        // DBs created with older versions of localForage will simply not have the blob type.\n        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n            blobType = matcher[1];\n            serializedString = serializedString.substring(matcher[0].length);\n        }\n        var buffer = stringToBuffer(serializedString);    // Return the right type based on the code/type set during\n                                                          // serialization.\n        // Return the right type based on the code/type set during\n        // serialization.\n        switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n        }\n    }\n    var localforageSerializer = {\n        serialize: serialize,\n        deserialize: deserialize,\n        stringToBuffer: stringToBuffer,\n        bufferToString: bufferToString\n    };\n    return localforageSerializer;\n});\ndefine('skylark-localForage/drivers/websql',[\n    '../utils/isWebSQLValid',\n    '../utils/serializer',\n    '../utils/promise',\n    '../utils/executeCallback',\n    '../utils/normalizeKey',\n    '../utils/getCallback'\n], function (isWebSQLValid, serializer, Promise, executeCallback, normalizeKey, getCallback) {\n    'use strict';\n    /*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n    function createDbTable(t, dbInfo, callback, errorCallback) {\n        t.executeSql(`CREATE TABLE IF NOT EXISTS ${ dbInfo.storeName } ` + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n    }    // Open the WebSQL database (automatically creates one if one didn't\n         // previously exist), using any options set in the config.\n    // Open the WebSQL database (automatically creates one if one didn't\n    // previously exist), using any options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = { db: null };\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n            }\n        }\n        var dbInfoPromise = new Promise(function (resolve, reject) {\n            // Open the database; the openDatabase API will automatically\n            // create it for us if it doesn't exist.\n            try {\n                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n            } catch (e) {\n                return reject(e);\n            }    // Create our key/value table if it doesn't exist.\n            // Create our key/value table if it doesn't exist.\n            dbInfo.db.transaction(function (t) {\n                createDbTable(t, dbInfo, function () {\n                    self._dbInfo = dbInfo;\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            }, reject);\n        });\n        dbInfo.serializer = serializer;\n        return dbInfoPromise;\n    }\n    function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n        t.executeSql(sqlStatement, args, callback, function (t, error) {\n            if (error.code === error.SYNTAX_ERR) {\n                t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                    if (!results.rows.length) {\n                        // if the table is missing (was deleted)\n                        // re-create it table and retry\n                        createDbTable(t, dbInfo, function () {\n                            t.executeSql(sqlStatement, args, callback, errorCallback);\n                        }, errorCallback);\n                    } else {\n                        errorCallback(t, error);\n                    }\n                }, errorCallback);\n            } else {\n                errorCallback(t, error);\n            }\n        }, errorCallback);\n    }\n    function getItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `SELECT * FROM ${ dbInfo.storeName } WHERE key = ? LIMIT 1`, [key], function (t, results) {\n                        var result = results.rows.length ? results.rows.item(0).value : null;    // Check to see if this is serialized content we need to\n                                                                                                 // unpack.\n                        // Check to see if this is serialized content we need to\n                        // unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n                        resolve(result);\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function iterate(iterator, callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `SELECT * FROM ${ dbInfo.storeName }`, [], function (t, results) {\n                        var rows = results.rows;\n                        var length = rows.length;\n                        for (var i = 0; i < length; i++) {\n                            var item = rows.item(i);\n                            var result = item.value;    // Check to see if this is serialized content\n                                                        // we need to unpack.\n                            // Check to see if this is serialized content\n                            // we need to unpack.\n                            if (result) {\n                                result = dbInfo.serializer.deserialize(result);\n                            }\n                            result = iterator(result, item.key, i + 1);    // void(0) prevents problems with redefinition\n                                                                           // of `undefined`.\n                            // void(0) prevents problems with redefinition\n                            // of `undefined`.\n                            if (result !== void 0) {\n                                resolve(result);\n                                return;\n                            }\n                        }\n                        resolve();\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function _setItem(key, value, callback, retriesLeft) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                // The localStorage API doesn't return undefined values in an\n                // \"expected\" way, so undefined is always cast to null in all\n                // drivers. See: https://github.com/mozilla/localForage/pull/42\n                if (value === undefined) {\n                    value = null;\n                }    // Save the original value to pass to the callback.\n                // Save the original value to pass to the callback.\n                var originalValue = value;\n                var dbInfo = self._dbInfo;\n                dbInfo.serializer.serialize(value, function (value, error) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        dbInfo.db.transaction(function (t) {\n                            tryExecuteSql(t, dbInfo, `INSERT OR REPLACE INTO ${ dbInfo.storeName } ` + '(key, value) VALUES (?, ?)', [\n                                key,\n                                value\n                            ], function () {\n                                resolve(originalValue);\n                            }, function (t, error) {\n                                reject(error);\n                            });\n                        }, function (sqlError) {\n                            // The transaction failed; check\n                            // to see if it's a quota error.\n                            if (sqlError.code === sqlError.QUOTA_ERR) {\n                                // We reject the callback outright for now, but\n                                // it's worth trying to re-run the transaction.\n                                // Even if the user accepts the prompt to use\n                                // more storage on Safari, this error will\n                                // be called.\n                                //\n                                // Try to re-run the transaction.\n                                if (retriesLeft > 0) {\n                                    resolve(_setItem.apply(self, [\n                                        key,\n                                        originalValue,\n                                        callback,\n                                        retriesLeft - 1\n                                    ]));\n                                    return;\n                                }\n                                reject(sqlError);\n                            }\n                        });\n                    }\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function setItem(key, value, callback) {\n        return _setItem.apply(this, [\n            key,\n            value,\n            callback,\n            1\n        ]);\n    }\n    function removeItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `DELETE FROM ${ dbInfo.storeName } WHERE key = ?`, [key], function () {\n                        resolve();\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Deletes every item in the table.\n         // TODO: Find out if this resets the AUTO_INCREMENT number.\n    // Deletes every item in the table.\n    // TODO: Find out if this resets the AUTO_INCREMENT number.\n    function clear(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `DELETE FROM ${ dbInfo.storeName }`, [], function () {\n                        resolve();\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Does a simple `COUNT(key)` to get the number of items stored in\n         // localForage.\n    // Does a simple `COUNT(key)` to get the number of items stored in\n    // localForage.\n    function length(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    // Ahhh, SQL makes this one soooooo easy.\n                    tryExecuteSql(t, dbInfo, `SELECT COUNT(key) as c FROM ${ dbInfo.storeName }`, [], function (t, results) {\n                        var result = results.rows.item(0).c;\n                        resolve(result);\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Return the key located at key index X; essentially gets the key from a\n         // `WHERE id = ?`. This is the most efficient way I can think to implement\n         // this rarely-used (in my experience) part of the API, but it can seem\n         // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n         // the ID of each key will change every time it's updated. Perhaps a stored\n         // procedure for the `setItem()` SQL would solve this problem?\n         // TODO: Don't change ID on `setItem()`.\n    // Return the key located at key index X; essentially gets the key from a\n    // `WHERE id = ?`. This is the most efficient way I can think to implement\n    // this rarely-used (in my experience) part of the API, but it can seem\n    // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n    // the ID of each key will change every time it's updated. Perhaps a stored\n    // procedure for the `setItem()` SQL would solve this problem?\n    // TODO: Don't change ID on `setItem()`.\n    function key(n, callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `SELECT key FROM ${ dbInfo.storeName } WHERE id = ? LIMIT 1`, [n + 1], function (t, results) {\n                        var result = results.rows.length ? results.rows.item(0).key : null;\n                        resolve(result);\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function keys(callback) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            self.ready().then(function () {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function (t) {\n                    tryExecuteSql(t, dbInfo, `SELECT key FROM ${ dbInfo.storeName }`, [], function (t, results) {\n                        var keys = [];\n                        for (var i = 0; i < results.rows.length; i++) {\n                            keys.push(results.rows.item(i).key);\n                        }\n                        resolve(keys);\n                    }, function (t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // https://www.w3.org/TR/webdatabase/#databases\n         // > There is no way to enumerate or delete the databases available for an origin from this API.\n    // https://www.w3.org/TR/webdatabase/#databases\n    // > There is no way to enumerate or delete the databases available for an origin from this API.\n    function getAllStoreNames(db) {\n        return new Promise(function (resolve, reject) {\n            db.transaction(function (t) {\n                t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                    var storeNames = [];\n                    for (var i = 0; i < results.rows.length; i++) {\n                        storeNames.push(results.rows.item(i).name);\n                    }\n                    resolve({\n                        db,\n                        storeNames\n                    });\n                }, function (t, error) {\n                    reject(error);\n                });\n            }, function (sqlError) {\n                reject(sqlError);\n            });\n        });\n    }\n    function dropInstance(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        var currentConfig = this.config();\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n            promise = Promise.reject('Invalid arguments');\n        } else {\n            promise = new Promise(function (resolve) {\n                var db;\n                if (options.name === currentConfig.name) {\n                    // use the db reference of the current instance\n                    db = self._dbInfo.db;\n                } else {\n                    db = openDatabase(options.name, '', '', 0);\n                }\n                if (!options.storeName) {\n                    // drop all database tables\n                    resolve(getAllStoreNames(db));\n                } else {\n                    resolve({\n                        db,\n                        storeNames: [options.storeName]\n                    });\n                }\n            }).then(function (operationInfo) {\n                return new Promise(function (resolve, reject) {\n                    operationInfo.db.transaction(function (t) {\n                        function dropTable(storeName) {\n                            return new Promise(function (resolve, reject) {\n                                t.executeSql(`DROP TABLE IF EXISTS ${ storeName }`, [], function () {\n                                    resolve();\n                                }, function (t, error) {\n                                    reject(error);\n                                });\n                            });\n                        }\n                        var operations = [];\n                        for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                            operations.push(dropTable(operationInfo.storeNames[i]));\n                        }\n                        Promise.all(operations).then(function () {\n                            resolve();\n                        }).catch(function (e) {\n                            reject(e);\n                        });\n                    }, function (sqlError) {\n                        reject(sqlError);\n                    });\n                });\n            });\n        }\n        executeCallback(promise, callback);\n        return promise;\n    }\n    var webSQLStorage = {\n        _driver: 'webSQLStorage',\n        _initStorage: _initStorage,\n        _support: isWebSQLValid(),\n        iterate: iterate,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys,\n        dropInstance: dropInstance\n    };\n    return webSQLStorage;\n});\ndefine('skylark-localForage/utils/isLocalStorageValid',[],function () {\n    'use strict';\n    function isLocalStorageValid() {\n        try {\n            return typeof localStorage !== 'undefined' && 'setItem' in localStorage && // in IE8 typeof localStorage.setItem === 'object'\n            !!localStorage.setItem;\n        } catch (e) {\n            return false;\n        }\n    }\n    return isLocalStorageValid;\n});\ndefine('skylark-localForage/drivers/localstorage',[\n    '../utils/isLocalStorageValid',\n    '../utils/serializer',\n    '../utils/promise',\n    '../utils/executeCallback',\n    '../utils/normalizeKey',\n    '../utils/getCallback'\n], function (isLocalStorageValid, serializer, Promise, executeCallback, normalizeKey, getCallback) {\n    'use strict';\n    function _getKeyPrefix(options, defaultConfig) {\n        var keyPrefix = options.name + '/';\n        if (options.storeName !== defaultConfig.storeName) {\n            keyPrefix += options.storeName + '/';\n        }\n        return keyPrefix;\n    }    // Check if localStorage throws when saving an item\n    // Check if localStorage throws when saving an item\n    function checkIfLocalStorageThrows() {\n        var localStorageTestKey = '_localforage_support_test';\n        try {\n            localStorage.setItem(localStorageTestKey, true);\n            localStorage.removeItem(localStorageTestKey);\n            return false;\n        } catch (e) {\n            return true;\n        }\n    }    // Check if localStorage is usable and allows to save an item\n         // This method checks if localStorage is usable in Safari Private Browsing\n         // mode, or in any other case where the available quota for localStorage\n         // is 0 and there wasn't any saved items yet.\n    // Check if localStorage is usable and allows to save an item\n    // This method checks if localStorage is usable in Safari Private Browsing\n    // mode, or in any other case where the available quota for localStorage\n    // is 0 and there wasn't any saved items yet.\n    function _isLocalStorageUsable() {\n        return !checkIfLocalStorageThrows() || localStorage.length > 0;\n    }    // Config the localStorage backend, using options set in the config.\n    // Config the localStorage backend, using options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = {};\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = options[i];\n            }\n        }\n        dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n        if (!_isLocalStorageUsable()) {\n            return Promise.reject();\n        }\n        self._dbInfo = dbInfo;\n        dbInfo.serializer = serializer;\n        return Promise.resolve();\n    }    // Remove all keys from the datastore, effectively destroying all data in\n         // the app's key/value store!\n    // Remove all keys from the datastore, effectively destroying all data in\n    // the app's key/value store!\n    function clear(callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n            var keyPrefix = self._dbInfo.keyPrefix;\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Retrieve an item from the store. Unlike the original async_storage\n         // library in Gaia, we don't modify return values at all. If a key's value\n         // is `undefined`, we pass that value to the callback function.\n    // Retrieve an item from the store. Unlike the original async_storage\n    // library in Gaia, we don't modify return values at all. If a key's value\n    // is `undefined`, we pass that value to the callback function.\n    function getItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var result = localStorage.getItem(dbInfo.keyPrefix + key);    // If a result was found, parse it from the serialized\n                                                                          // string into a JS object. If result isn't truthy, the key\n                                                                          // is likely undefined and we'll pass it straight to the\n                                                                          // callback.\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the key\n            // is likely undefined and we'll pass it straight to the\n            // callback.\n            if (result) {\n                result = dbInfo.serializer.deserialize(result);\n            }\n            return result;\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Iterate over all items in the store.\n    // Iterate over all items in the store.\n    function iterate(iterator, callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var keyPrefix = dbInfo.keyPrefix;\n            var keyPrefixLength = keyPrefix.length;\n            var length = localStorage.length;    // We use a dedicated iterator instead of the `i` variable below\n                                                 // so other keys we fetch in localStorage aren't counted in\n                                                 // the `iterationNumber` argument passed to the `iterate()`\n                                                 // callback.\n                                                 //\n                                                 // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n            // We use a dedicated iterator instead of the `i` variable below\n            // so other keys we fetch in localStorage aren't counted in\n            // the `iterationNumber` argument passed to the `iterate()`\n            // callback.\n            //\n            // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n            var iterationNumber = 1;\n            for (var i = 0; i < length; i++) {\n                var key = localStorage.key(i);\n                if (key.indexOf(keyPrefix) !== 0) {\n                    continue;\n                }\n                var value = localStorage.getItem(key);    // If a result was found, parse it from the serialized\n                                                          // string into a JS object. If result isn't truthy, the\n                                                          // key is likely undefined and we'll pass it straight\n                                                          // to the iterator.\n                // If a result was found, parse it from the serialized\n                // string into a JS object. If result isn't truthy, the\n                // key is likely undefined and we'll pass it straight\n                // to the iterator.\n                if (value) {\n                    value = dbInfo.serializer.deserialize(value);\n                }\n                value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n                if (value !== void 0) {\n                    return value;\n                }\n            }\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Same as localStorage's key() method, except takes a callback.\n    // Same as localStorage's key() method, except takes a callback.\n    function key(n, callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var result;\n            try {\n                result = localStorage.key(n);\n            } catch (error) {\n                result = null;\n            }    // Remove the prefix from the key, if a key is found.\n            // Remove the prefix from the key, if a key is found.\n            if (result) {\n                result = result.substring(dbInfo.keyPrefix.length);\n            }\n            return result;\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function keys(callback) {\n        var self = this;\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var length = localStorage.length;\n            var keys = [];\n            for (var i = 0; i < length; i++) {\n                var itemKey = localStorage.key(i);\n                if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                    keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n                }\n            }\n            return keys;\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Supply the number of keys in the datastore to the callback function.\n    // Supply the number of keys in the datastore to the callback function.\n    function length(callback) {\n        var self = this;\n        var promise = self.keys().then(function (keys) {\n            return keys.length;\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Remove an item from the store, nice and simple.\n    // Remove an item from the store, nice and simple.\n    function removeItem(key, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            localStorage.removeItem(dbInfo.keyPrefix + key);\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }    // Set a key's value and run an optional callback once the value is set.\n         // Unlike Gaia's implementation, the callback function is passed the value,\n         // in case you want to operate on that value only after you're sure it\n         // saved, or something like that.\n    // Set a key's value and run an optional callback once the value is set.\n    // Unlike Gaia's implementation, the callback function is passed the value,\n    // in case you want to operate on that value only after you're sure it\n    // saved, or something like that.\n    function setItem(key, value, callback) {\n        var self = this;\n        key = normalizeKey(key);\n        var promise = self.ready().then(function () {\n            // Convert undefined values to null.\n            // https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }    // Save the original value to pass to the callback.\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n            return new Promise(function (resolve, reject) {\n                var dbInfo = self._dbInfo;\n                dbInfo.serializer.serialize(value, function (value, error) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        try {\n                            localStorage.setItem(dbInfo.keyPrefix + key, value);\n                            resolve(originalValue);\n                        } catch (e) {\n                            // localStorage capacity exceeded.\n                            // TODO: Make this a specific error/event.\n                            if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                                reject(e);\n                            }\n                            reject(e);\n                        }\n                    }\n                });\n            });\n        });\n        executeCallback(promise, callback);\n        return promise;\n    }\n    function dropInstance(options, callback) {\n        callback = getCallback.apply(this, arguments);\n        options = typeof options !== 'function' && options || {};\n        if (!options.name) {\n            var currentConfig = this.config();\n            options.name = options.name || currentConfig.name;\n            options.storeName = options.storeName || currentConfig.storeName;\n        }\n        var self = this;\n        var promise;\n        if (!options.name) {\n            promise = Promise.reject('Invalid arguments');\n        } else {\n            promise = new Promise(function (resolve) {\n                if (!options.storeName) {\n                    resolve(`${ options.name }/`);\n                } else {\n                    resolve(_getKeyPrefix(options, self._defaultConfig));\n                }\n            }).then(function (keyPrefix) {\n                for (var i = localStorage.length - 1; i >= 0; i--) {\n                    var key = localStorage.key(i);\n                    if (key.indexOf(keyPrefix) === 0) {\n                        localStorage.removeItem(key);\n                    }\n                }\n            });\n        }\n        executeCallback(promise, callback);\n        return promise;\n    }\n    var localStorageWrapper = {\n        _driver: 'localStorageWrapper',\n        _initStorage: _initStorage,\n        _support: isLocalStorageValid(),\n        iterate: iterate,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys,\n        dropInstance: dropInstance\n    };\n    return localStorageWrapper;\n});\ndefine('skylark-localForage/utils/includes',[],function () {\n    'use strict';\n    const sameValue = (x, y) => x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n    const includes = (array, searchElement) => {\n        const len = array.length;\n        let i = 0;\n        while (i < len) {\n            if (sameValue(array[i], searchElement)) {\n                return true;\n            }\n            i++;\n        }\n        return false;\n    };\n    return includes;\n});\ndefine('skylark-localForage/utils/isArray',[],function () {\n    'use strict';\n    const isArray = Array.isArray || function (arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n    return isArray;\n});\ndefine('skylark-localForage/localforage',[\n    './drivers/indexeddb',\n    './drivers/websql',\n    './drivers/localstorage',\n    './utils/serializer',\n    './utils/promise',\n    './utils/executeCallback',\n    './utils/executeTwoCallbacks',\n    './utils/includes',\n    './utils/isArray'\n], function (idbDriver, websqlDriver, localstorageDriver, serializer, Promise, executeCallback, executeTwoCallbacks, includes, isArray) {\n    'use strict';\n    // Drivers are stored here when `defineDriver()` is called.\n    // They are shared across all instances of localForage.\n    const DefinedDrivers = {};\n    const DriverSupport = {};\n    const DefaultDrivers = {\n        INDEXEDDB: idbDriver,\n        WEBSQL: websqlDriver,\n        LOCALSTORAGE: localstorageDriver\n    };\n    const DefaultDriverOrder = [\n        DefaultDrivers.INDEXEDDB._driver,\n        DefaultDrivers.WEBSQL._driver,\n        DefaultDrivers.LOCALSTORAGE._driver\n    ];\n    const OptionalDriverMethods = ['dropInstance'];\n    const LibraryMethods = [\n        'clear',\n        'getItem',\n        'iterate',\n        'key',\n        'keys',\n        'length',\n        'removeItem',\n        'setItem'\n    ].concat(OptionalDriverMethods);\n    const DefaultConfig = {\n        description: '',\n        driver: DefaultDriverOrder.slice(),\n        name: 'localforage',\n        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n        // we can use without a prompt.\n        size: 4980736,\n        storeName: 'keyvaluepairs',\n        version: 1\n    };\n    function callWhenReady(localForageInstance, libraryMethod) {\n        localForageInstance[libraryMethod] = function () {\n            const _args = arguments;\n            return localForageInstance.ready().then(function () {\n                return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n            });\n        };\n    }\n    function extend() {\n        for (let i = 1; i < arguments.length; i++) {\n            const arg = arguments[i];\n            if (arg) {\n                for (let key in arg) {\n                    if (arg.hasOwnProperty(key)) {\n                        if (isArray(arg[key])) {\n                            arguments[0][key] = arg[key].slice();\n                        } else {\n                            arguments[0][key] = arg[key];\n                        }\n                    }\n                }\n            }\n        }\n        return arguments[0];\n    }\n    class LocalForage {\n        constructor(options) {\n            for (let driverTypeKey in DefaultDrivers) {\n                if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                    const driver = DefaultDrivers[driverTypeKey];\n                    const driverName = driver._driver;\n                    this[driverTypeKey] = driverName;\n                    if (!DefinedDrivers[driverName]) {\n                        // we don't need to wait for the promise,\n                        // since the default drivers can be defined\n                        // in a blocking manner\n                        this.defineDriver(driver);\n                    }\n                }\n            }\n            this._defaultConfig = extend({}, DefaultConfig);\n            this._config = extend({}, this._defaultConfig, options);\n            this._driverSet = null;\n            this._initDriver = null;\n            this._ready = false;\n            this._dbInfo = null;\n            this._wrapLibraryMethodsWithReady();\n            this.setDriver(this._config.driver).catch(() => {\n            });\n        }    // Set any config values for localForage; can be called anytime before\n             // the first API call (e.g. `getItem`, `setItem`).\n             // We loop through options so we don't overwrite existing config\n             // values.\n\n        // Set any config values for localForage; can be called anytime before\n        // the first API call (e.g. `getItem`, `setItem`).\n        // We loop through options so we don't overwrite existing config\n        // values.\n        config(options) {\n            // If the options argument is an object, we use it to set values.\n            // Otherwise, we return either a specified config value or all\n            // config values.\n            if (typeof options === 'object') {\n                // If localforage is ready and fully initialized, we can't set\n                // any new configuration values. Instead, we return an error.\n                if (this._ready) {\n                    return new Error(\"Can't call config() after localforage \" + 'has been used.');\n                }\n                for (let i in options) {\n                    if (i === 'storeName') {\n                        options[i] = options[i].replace(/\\W/g, '_');\n                    }\n                    if (i === 'version' && typeof options[i] !== 'number') {\n                        return new Error('Database version must be a number.');\n                    }\n                    this._config[i] = options[i];\n                }    // after all config options are set and\n                     // the driver option is used, try setting it\n                // after all config options are set and\n                // the driver option is used, try setting it\n                if ('driver' in options && options.driver) {\n                    return this.setDriver(this._config.driver);\n                }\n                return true;\n            } else if (typeof options === 'string') {\n                return this._config[options];\n            } else {\n                return this._config;\n            }\n        }    // Used to define a custom driver, shared across all instances of\n             // localForage.\n\n        // Used to define a custom driver, shared across all instances of\n        // localForage.\n        defineDriver(driverObject, callback, errorCallback) {\n            const promise = new Promise(function (resolve, reject) {\n                try {\n                    const driverName = driverObject._driver;\n                    const complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');    // A driver name should be defined and not overlap with the\n                                                                                                                                                       // library-defined, default drivers.\n                    // A driver name should be defined and not overlap with the\n                    // library-defined, default drivers.\n                    if (!driverObject._driver) {\n                        reject(complianceError);\n                        return;\n                    }\n                    const driverMethods = LibraryMethods.concat('_initStorage');\n                    for (let i = 0, len = driverMethods.length; i < len; i++) {\n                        const driverMethodName = driverMethods[i];    // when the property is there,\n                                                                      // it should be a method even when optional\n                        // when the property is there,\n                        // it should be a method even when optional\n                        const isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                        if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                            reject(complianceError);\n                            return;\n                        }\n                    }\n                    const configureMissingMethods = function () {\n                        const methodNotImplementedFactory = function (methodName) {\n                            return function () {\n                                const error = new Error(`Method ${ methodName } is not implemented by the current driver`);\n                                const promise = Promise.reject(error);\n                                executeCallback(promise, arguments[arguments.length - 1]);\n                                return promise;\n                            };\n                        };\n                        for (let i = 0, len = OptionalDriverMethods.length; i < len; i++) {\n                            const optionalDriverMethod = OptionalDriverMethods[i];\n                            if (!driverObject[optionalDriverMethod]) {\n                                driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                            }\n                        }\n                    };\n                    configureMissingMethods();\n                    const setDriverSupport = function (support) {\n                        if (DefinedDrivers[driverName]) {\n                            console.info(`Redefining LocalForage driver: ${ driverName }`);\n                        }\n                        DefinedDrivers[driverName] = driverObject;\n                        DriverSupport[driverName] = support;    // don't use a then, so that we can define\n                                                                // drivers that have simple _support methods\n                                                                // in a blocking manner\n                        // don't use a then, so that we can define\n                        // drivers that have simple _support methods\n                        // in a blocking manner\n                        resolve();\n                    };\n                    if ('_support' in driverObject) {\n                        if (driverObject._support && typeof driverObject._support === 'function') {\n                            driverObject._support().then(setDriverSupport, reject);\n                        } else {\n                            setDriverSupport(!!driverObject._support);\n                        }\n                    } else {\n                        setDriverSupport(true);\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            });\n            executeTwoCallbacks(promise, callback, errorCallback);\n            return promise;\n        }\n        driver() {\n            return this._driver || null;\n        }\n        getDriver(driverName, callback, errorCallback) {\n            const getDriverPromise = DefinedDrivers[driverName] ? Promise.resolve(DefinedDrivers[driverName]) : Promise.reject(new Error('Driver not found.'));\n            executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n            return getDriverPromise;\n        }\n        getSerializer(callback) {\n            const serializerPromise = Promise.resolve(serializer);\n            executeTwoCallbacks(serializerPromise, callback);\n            return serializerPromise;\n        }\n        ready(callback) {\n            const self = this;\n            const promise = self._driverSet.then(() => {\n                if (self._ready === null) {\n                    self._ready = self._initDriver();\n                }\n                return self._ready;\n            });\n            executeTwoCallbacks(promise, callback, callback);\n            return promise;\n        }\n        setDriver(drivers, callback, errorCallback) {\n            const self = this;\n            if (!isArray(drivers)) {\n                drivers = [drivers];\n            }\n            const supportedDrivers = this._getSupportedDrivers(drivers);\n            function setDriverToConfig() {\n                self._config.driver = self.driver();\n            }\n            function extendSelfWithDriver(driver) {\n                self._extend(driver);\n                setDriverToConfig();\n                self._ready = self._initStorage(self._config);\n                return self._ready;\n            }\n            function initDriver(supportedDrivers) {\n                return function () {\n                    let currentDriverIndex = 0;\n                    function driverPromiseLoop() {\n                        while (currentDriverIndex < supportedDrivers.length) {\n                            let driverName = supportedDrivers[currentDriverIndex];\n                            currentDriverIndex++;\n                            self._dbInfo = null;\n                            self._ready = null;\n                            return self.getDriver(driverName).then(extendSelfWithDriver).catch(driverPromiseLoop);\n                        }\n                        setDriverToConfig();\n                        const error = new Error('No available storage method found.');\n                        self._driverSet = Promise.reject(error);\n                        return self._driverSet;\n                    }\n                    return driverPromiseLoop();\n                };\n            }    // There might be a driver initialization in progress\n                 // so wait for it to finish in order to avoid a possible\n                 // race condition to set _dbInfo\n            // There might be a driver initialization in progress\n            // so wait for it to finish in order to avoid a possible\n            // race condition to set _dbInfo\n            const oldDriverSetDone = this._driverSet !== null ? this._driverSet.catch(() => Promise.resolve()) : Promise.resolve();\n            this._driverSet = oldDriverSetDone.then(() => {\n                const driverName = supportedDrivers[0];\n                self._dbInfo = null;\n                self._ready = null;\n                return self.getDriver(driverName).then(driver => {\n                    self._driver = driver._driver;\n                    setDriverToConfig();\n                    self._wrapLibraryMethodsWithReady();\n                    self._initDriver = initDriver(supportedDrivers);\n                });\n            }).catch(() => {\n                setDriverToConfig();\n                const error = new Error('No available storage method found.');\n                self._driverSet = Promise.reject(error);\n                return self._driverSet;\n            });\n            executeTwoCallbacks(this._driverSet, callback, errorCallback);\n            return this._driverSet;\n        }\n        supports(driverName) {\n            return !!DriverSupport[driverName];\n        }\n        _extend(libraryMethodsAndProperties) {\n            extend(this, libraryMethodsAndProperties);\n        }\n        _getSupportedDrivers(drivers) {\n            const supportedDrivers = [];\n            for (let i = 0, len = drivers.length; i < len; i++) {\n                const driverName = drivers[i];\n                if (this.supports(driverName)) {\n                    supportedDrivers.push(driverName);\n                }\n            }\n            return supportedDrivers;\n        }\n        _wrapLibraryMethodsWithReady() {\n            // Add a stub for each driver API method that delays the call to the\n            // corresponding driver method until localForage is ready. These stubs\n            // will be replaced by the driver methods as soon as the driver is\n            // loaded, so there is no performance impact.\n            for (let i = 0, len = LibraryMethods.length; i < len; i++) {\n                callWhenReady(this, LibraryMethods[i]);\n            }\n        }\n        createInstance(options) {\n            return new LocalForage(options);\n        }\n    }    // The actual localForage object that we expose as a module or via a\n         // global. It's extended by pulling in one of our other libraries.\n    // The actual localForage object that we expose as a module or via a\n    // global. It's extended by pulling in one of our other libraries.\n    return new LocalForage();\n});\ndefine('skylark-localForage/main',[\r\n\t\"skylark-langx-ns\",\r\n\t\"./localforage\"\r\n],function(skylark,localforage){\r\n\treturn skylark.attach(\"intg.localforage\",localforage);\r\n});\ndefine('skylark-localForage', ['skylark-localForage/main'], function (main) { return main; });\n\n"]}